{"./":{"url":"./","title":"实验简介","keywords":"","body":"miniSysY 编译实验 实验概述 SysY1 语言是本实验的源语言。是一个c语言的子集，SysY 语言是单文件的，以 .sy 作为后缀，去除了c语言中的 include/define/pointer/struct 等较复杂特性，sysy 语言本身不具有 IO 功能，通过链接运行时库的方式进行 IO。 LLVM 是一个模块化的、可重用的编译器和工具链的集合，目的是提供一个现代的、基于 SSA 的、能够支持任意静态和动态编译的编程语言的编译策略。在最近几年已经成为表现上能够和 gcc 对标的项目。 LLVM IR 是 LLVM 项目中通用的中间代码，作为源语言和体系架构的连接部分，是学生需要从源语言中编译并翻译到的目标语言。 本实验的所有变动以及修改都是公开的（包括目前未正式发布的实验），你可以在这里查看我们的进度并通过 issue 的形式向我们提出意见和建议。 实验目的 本实验希望通过将复杂且庞大的 SysY 语言的特性拆分为多个小的模块与实验，引导同学们在思考-设计-实现-重新设计的过程中实现从源语言到 LLVM IR 的编译器，了解编译技术的整个流程，并且掌握一定的优化能力。 若完成所有实验，同学应该： 学会并理解了编译器的翻译流程 掌握了词法分析与语法分析的原理以及操作 掌握了语法制导翻译的原理以及操作 了解了编译优化的思想 掌握了部分简单的编译优化 熟悉了 gcc, llvm 等常见编译套件的使用以及用法 实验中不会涉及的东西： 手动内存管理 寄存器分配 对 ABI 的处理 体系结构相关的优化 为什么选择 LLVM IR 而不是 GIMPLE 或者其他体系架构汇编与栈式虚拟机： GIMPLE 过于复杂，学习成本太高，不适宜用作教学实验。 软件学院并没有系统性地学习过 CISC 或者是 RISC 指令集，而且大三上学期软件学院其他课程过于繁重，增加指令集的学习会导致学习内容大幅增加。LLVM IR 本身不需要太多对体系架构的知识，并且完全能够胜任一门目标语言的工作。（而且助教评测起来也很方便） 栈式虚拟机本身结构较为简单，并且生成对应代码也比较简单，但是脱离了现在实际应用中的环境，学习栈式虚拟机指令和学习 LLVM IR 的成本相当，但 LLVM IR 具有实际且广泛的应用场景。 1. 具体请参考语言定义页面 ↩ "},"report.html":{"url":"report.html","title":"报告要求","keywords":"","body":"实验报告要求 实验报告的提交以 lab 为基本单位，每完成一次 lab ,你都应该提交一次实验报告。 格式要求： PDF 提交地址点击此处 提交文件名：学号_姓名_labx （x为本次 lab 编号） 内容要求： 学号+姓名 简要介绍，你在完成这个 lab 中的各个 part 时都做了哪些工作，为什么要用（你采用的）这种方法完成。 实验指导中每个 part 中留下的思考题的回答。（鼓励但不强制，这不会成为评分依据） 如果你复用或者借鉴了参考代码或其他实现（关于借鉴与抄袭的界定请见诚信页），请明确写出你借鉴了哪些内容。 其他要求： 请尽量精简你的报告，叙述清楚上述几点即可，实验的分数和报告的长度没有严格相关性。 报告太长（超过1000字）我们会酌情扣分（当然如果你实现了一个比较难的 part 而且你确实有很多想说的我们也不会因此扣你的分）。 "},"integrity.html":{"url":"integrity.html","title":"诚信","keywords":"","body":"诚信 做正确的事，即使没有人在看着你。 红线： 不得抄袭其他同学实现。 不得直接查看其他同学源码。（但我们鼓励查看示例编译器以及其他实现的源码） 不得直接复制示例编译器代码。 抄袭其他同学代码的行为一经核实，双方实验成绩记为原来的一半，你有义务在课程期间保护自己的代码。 严重抄袭示例编译器的行为一经核实，实验成绩记为原来的一半。 我们鼓励对抄袭行为的举报，对经过核实情况为真的举报，我们会保护举报人的隐私并给予一定分数奖励。 一些例子： NONONO 直接复制示例编译器 NONONO “莫卡，我实在写不出来了，你把你代码发给我看下吧，我保证不抄” YESYESYES 在群里不涉及大量源码地友善的讨论某个part实现的思路 YESYESYES 从其他实现（比如llvm,比如使用了此文法的比赛的参赛作品）中借鉴他们的实现方法 "},"pre/llvm.html":{"url":"pre/llvm.html","title":"LLVM 相关内容","keywords":"","body":"LLVM 与 LLVM IR 本章各小节主要内容 LLVM 工具链下载：如题 LLVM 工具链介绍：介绍了 LLVM Project 中最常用的以及和本实验关系较大的工具 LLVM IR 快速上手：介绍了 LLVM IR 中最重要，最基本的结构，简单介绍了 LLVM IR 的组织方式 LLVM IR SSA 介绍：介绍了 LLVM IR 实现 SSA 的方式以及生成存取内存形式的 IR 的方法 LLVM 架构中最重要的概念，以及编译器设计的提示：介绍了 LLVM 架构中的一些概念 推荐指令：推荐了一些在实验中可能会用到的指令 这部分会涉及到后面的知识，看不懂其中的一些地方是正常的。 随着实验的更新，本章节中的内容也会不断更新，请注意查看。 "},"pre/llvm_download.html":{"url":"pre/llvm_download.html","title":"LLVM 工具链下载","keywords":"","body":"LLVM 相关工具链下载 注意：在我们的实验中要求 Clang 和 LLVM 的版本至少为 10.0。 Ubuntu 20.04 或更新版本 对于 Ubuntu 20.04 或更新版本，官方源中的 LLVM 版本已经默认为 10+，因此执行以下命令即可安装： $ sudo apt-get install llvm $ sudo apt-get install clang 安装完成后可以通过以下命令进行测试： $ clang -v # 查看版本，若出现版本信息则说明安装成功 $ lli --version # 查看版本，若出现版本信息则说明安装成功 18.04 对于 Ubuntu 18.04，官方源中的 LLVM 版本仍然停留在 6.0，因此你需要在安装时额外指定版本号： $ sudo apt-get install llvm-10 $ sudo apt-get install clang-10 相应的，使用时也需要在末尾额外加上 -10 用来指定版本，如 clang-10 或 lli-10。（当然你也可以用 alias 设置别名） 完成安装后可以通过以下命令进行测试： $ clang-10 -v # 查看版本，若出现版本信息则说明安装成功 $ lli-10 --version # 查看版本，若出现版本信息则说明安装成功 更老版本 快去更新。 如果你的 apt 因为某种原因不能用上述方式下载 把 # i386 not available deb http://apt.llvm.org/focal/ llvm-toolchain-focal main deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal main # 9 deb http://apt.llvm.org/focal/ llvm-toolchain-focal-9 main deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal-9 main # 10 deb http://apt.llvm.org/focal/ llvm-toolchain-focal-10 main deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal-10 main 加到 /etc/apt/sources.list然后在终端执行wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add -然后在终端执行apt-get install clang-10 lldb-10 lld-10 Redhat/Arch/...（Ubuntu/Debian 以外的） 因为问卷里面连上 2 名助教总共只有三个人用，所以不写了。通过包管理器下载 Clang 和 LLVM 即可（记得注意版本号）。 Fly B***h macOS Clang 在 macOS 上，如果你已经安装过 XCode 或 XCode Command Line Tools，则其默认已经附带了 clang。 你可以在「终端」应用中输入以下命令进行测试： $ clang -v # 查看 Clang 版本，若出现版本信息则说明安装成功 否则，你需要安装 XCode，或者运行以下命令安装 XCode Command Line Tools： $ xcode-select --install LLVM 由于 XCode 自带的 LLVM 工具链并不完整，因此你需要手动安装 LLVM 相关的包。 $ brew install llvm 安装完成后，你需要在配置文件中将 LLVM 的路径添加到 $PATH。 echo 'export PATH=\"/usr/local/opt/llvm/bin:$PATH\"' >> ~/.bash_profile 如果你使用的是 zsh 或者其他 shell，请自行在对应的配置文件中添加环境变量。 然后重启「终端」。 重启完成后，你可以在「终端」应用中输入以下命令进行测试： $ lli --version # 查看 LLVM 版本，若出现版本信息则说明安装成功 Windows “他们都大三了，该让他们使用 *nix 的东西了，不用写 Windows 的教程。” ——邵老师 当然在 Windows 上也可以安装相应的 Clang+LLVM 工具链，请自行摸索。 在本实验中，我们引入了 libsysy 库（在 这里 可以看到）为我们的程序提供 IO 方面的操作。 "},"pre/llvm_tool_chain.html":{"url":"pre/llvm_tool_chain.html","title":"LLVM 工具链介绍","keywords":"","body":"LLVM 工具链简介 如果你还没有完成工具链的下载，请先浏览 LLVM 工具链下载 一节。 LLVM 工具链里有很多有意思的工具，下面我们会选择其中对实验较为重要的几个进行介绍。这一部分会涉及到后面的知识，看不懂其中的一些地方是正常的。当然如果你对 LLVM 工具链和 LLVM IR 比较熟悉，可以直接跳过此节。 在开始介绍前，让我们先编写一个最简单的 a + b 程序作为测试文件。 //main.c int main(){ int a = 19260817; int b = 42; return a + b; } Clang Clang 作为 LLVM project 的一个子项目，是 LLVM 项目中 c/c++/obj-c 语言的前端，其用法与 GCC 基本相同。 你可以输入 clang -help 查看支持的所有选项。 预计将在实验中用到的指令有以下几个： # 生成可执行文件 $ clang main.c -o main # 查看编译的过程 $ clang -ccc-print-phases main.c # 生成 tokens $ clang -E -Xclang -dump-tokens main.c # 生成语法树 $ clang -fsyntax-only -Xclang -ast-dump main.c # 生成 llvm ir（不开优化） $ clang -S -emit-llvm main.c -o main.ll -O0 # 生成汇编（在本实验中用处不大） $ clang -S main.c -o main.s # 生成目标文件（在本实验中用处不大） $ clang -c main.c -o main.o 请尝试在命令行中输入这些命令，并看看都输出了什么。我们会在后面对其进行详细介绍。 lli lli 会解释或以 JIT 的形式运行 .bc 和 .ll 程序。其中，.bc 是 LLVM IR 的二进制格式（方便存储），.ll 是 LLVM IR 的可读代码格式（给人看的）。 在实验中，我们只需要用最简单的形式直接使用指令即可。以 main.c 为例： # 1. 生成 main.c 对应的 .ll 格式的文件 $ clang -S -emit-llvm main.c -o main.ll -O0 # 2. 用 lli 解释执行生成的 .ll 文件 $ lli main.ll 如果一切正常，查看上一条指令的返回值，你会看到： $ echo $? 187 # 即 (19260817 + 42) % 256 llvm-link lli 仅能运行单个 .ll 或 .bc 格式的文件，当我们想要使用别的库的时候，就需要用到 llvm-link。 在本实验中，我们引入了 libsysy 库（在 这里 可以看到）为我们的程序提供 IO 方面的操作。 例如，我们想要输出一个 int 的值，则需要用到 putint() 这个函数。我们可以直接在 main.c 中调用它： int main() { int a = 19260817; int b = 42; putint(a); return a + b; } 如果我们按照上面的方法直接用 lli 解释由这个 main.c 导出得到的 main.ll，会发现程序产生了错误： $ lli main.ll PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace. Stack dump: 1. Program arguments: lli main.ll zsh: segmentation fault (core dumped) lli main.ll 这是因为 lli 只解释了 main.ll 这一个文件，但是找不到库函数 putint 在哪。此时就需要用 llvm-link 来进行链接。 llvm-link 能够将多个 .ll 或 .bc 格式的文件链接为一个文件，例如： # 1. 分别导出 libsysy 和 main.c 对应的的 .ll 文件 $ clang -emit-llvm -S libsysy.c -o lib.ll $ clang -emit-llvm -S main.c -o main.ll # 2. 使用 llvm-link 将两个文件链接，生成新的 IR 文件 $ llvm-link main.ll lib.ll -o out.ll # 3. 用 lli 解释运行 $ lli out.ll 19260817 其他有用的工具 llc：可以将 .ll 形式的 IR 编译成指定体系结构的汇编 opt：LLVM 模块化的优化器和分析器。它以 LLVM 源文件为输入，对其运行指定的优化或分析，然后生成优化文件或输出分析结果。这个工具将会在挑战任务中介绍，在此不再展开。 "},"pre/llvm_ir_quick_primer.html":{"url":"pre/llvm_ir_quick_primer.html","title":"LLVM IR 快速上手","keywords":"","body":"LLVM IR 快速上手 写在前面 本节默认你已经看过了LLVM 工具链下载以及LLVM 工具链介绍两节的内容 如果你对 LLVM IR 比较熟悉，可以跳过本节 本节的内容较多较难，可能需要多看几遍才能消化。由于本节篇幅较长且助教精力有限，部分地方可能讲得不全面或存在错误，实际以 LLVM Lang Ref 以及 LLVM Programmer Manual 为准。 LLVM IR 简介 在开发编译器时，通常的做法是将源代码编译到某种中间表示（Intermediate Representation，一般称为 IR），然后再将 IR 翻译为目标体系结构的汇编（比如 MIPS 或 X86），这种做法相对于直接将源代码翻译为目标体系结构的好处主要有两个： 首先，有一些优化技术是目标平台无关的（例如作为我们实验挑战任务的死代码删除和常量折叠），我们只需要在 IR 上做这些优化，再翻译到不同的汇编，这样就能够在所有支持的体系结构上实现这种优化，这大大的减少了开发的工作量。 其次，假设我们有 m 种源语言和 n 种目标平台，如果我们直接将源代码翻译为目标平台的代码，那么我们就需要编写 m * n 个不同的编译器。然而，如果我们采用一种 IR 作为中转，先将源语言编译到这种 IR ，再将这种 IR 翻译到不同的目标平台上，那么我们就只需要实现 m + n 个编译器。 因此，目前常见的编译器都分为了三个部分，前端（front-end），中端（middle-end）以及后端（back-end），每一部分都承担了不同的功能： 前端：将源语言编译到 IR 中端：对 IR 进行优化 后端：将 IR 翻译为目标语言 同理，LLVM 也是按照这一结构设计的。 LLVM IR 具有三种表示形式，这三种中间格式是完全等价的： 在内存中的编译中间语言（我们无法通过文件的形式得到） 在硬盘上存储的二进制中间语言（格式为 .bc） 人类可读的代码语言（格式为 .ll） 本次实验要求输出 .ll 形式的 LLVM IR。 LLVM IR 示例程序 让我们通过一个小示例来快速熟悉 LLVM IR 的一些特性。在学习这部分的时候，你可能需要和推荐的 LLVM IR 指令 一节对照。 在接下来的任务中，我们会生成下面这个 C 程序的 .ll 形式 LLVM IR： // main.c int foo(int first, int second) { return first + second; } int a = 5; int main() { int b = 4; return foo(a, b); } 我们在命令行中输入 clang -emit-llvm -S main.c -o main.ll -O0（如果你还不知道这个命令中各个选项的含义，请先去看「LLVM 相关工具链下载」一节），然后打开同目录下的 main.ll 文件，会看到生成的内容如下所示： ; ModuleID = 'main.c' source_filename = \"main.c\" target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\" target triple = \"x86_64-pc-linux-gnu\" @a = dso_local global i32 5, align 4 ; Function Attrs: noinline nounwind optnone sspstrong uwtable define dso_local i32 @foo(i32 %0, i32 %1) #0 { %3 = alloca i32, align 4 %4 = alloca i32, align 4 store i32 %0, i32* %3, align 4 store i32 %1, i32* %4, align 4 %5 = load i32, i32* %3, align 4 %6 = load i32, i32* %4, align 4 %7 = add nsw i32 %5, %6 ret i32 %7 } ; Function Attrs: noinline nounwind optnone sspstrong uwtable define dso_local i32 @main() #0 { %1 = alloca i32, align 4 %2 = alloca i32, align 4 store i32 0, i32* %1, align 4 store i32 4, i32* %2, align 4 %3 = load i32, i32* @a, align 4 %4 = load i32, i32* %2, align 4 %5 = call i32 @foo(i32 %3, i32 %4) ret i32 %5 } attributes #0 = { noinline nounwind optnone sspstrong uwtable \"disable-tail-calls\"=\"false\" \"frame-pointer\"=\"all\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" } !llvm.module.flags = !{!0, !1, !2} !llvm.ident = !{!3} !0 = !{i32 1, !\"wchar_size\", i32 4} !1 = !{i32 7, !\"PIC Level\", i32 2} !2 = !{i32 7, !\"PIE Level\", i32 2} !3 = !{!\"clang version 12.0.1\"} 根据个人使用的硬件与系统不同，部分内容会出现较小区别，例如 target triple 与 target datalayout 是程序的标签属性说明，在我们的实验中并不要求生成它们；align 字段描述了程序的对齐属性；dso_local 是变量和函数的的运行时抢占说明符；以 ; 开头的字符串是 LLVM IR 的注释（这个最好记住）……这些内容在本实验里也不要求生成。 将上面谈到的内容都删除以后，我们的 .ll 文件依然是符合格式的。我们将无用的语句删去后，就只留下了需要关注的正文内容。为了方便同学的理解，我们还加上了相关的注释： ; 所有的全局变量都以 @ 为前缀，后面的 global 关键字表明了它是一个全局变量 @a = global i32 5 ; 注意，@a 的类型是 i32* ，后面会详细说明 ; 函数定义以 `define` 开头，i32 标明了函数的返回类型，其中 `foo`是函数的名字，`@` 是其前缀 ; 函数参数 (i32 %0, i32 %1) 分别标明了其第一、第二个参数的类型以及他们的名字 define i32 @foo(i32 %0, i32 %1) { ; 第一个参数的名字是 %0，类型是 i32；第二个参数的名字是 %1，类型是 i32。 ; 以 % 开头的符号表示虚拟寄存器，你可以把它当作一个临时变量（与全局变量相区分），或称之为临时寄存器 %3 = alloca i32 ; 为 %3 分配空间，其大小与一个 i32 类型的大小相同。%3 类型即为 i32* %4 = alloca i32 ; 同理，%4 类型为 i32* store i32 %0, i32* %3 ; 将 %0（i32）存入 %3（i32*） store i32 %1, i32* %4 ; 将 %1（i32）存入 %4（i32*） %5 = load i32, i32* %3 ; 从 %3（i32*）中 load 出一个值（类型为 i32），这个值的名字为 %5 %6 = load i32, i32* %4 ; 同理，从 %4（i32*） 中 load 出一个值给 %6（i32） %7 = add nsw i32 %5, %6 ; 将 %5（i32） 与 %6（i32）相加，其和的名字为 %7。nsw 是 \"No Signed Wrap\" 的缩写，表示无符号值运算 ret i32 %7 ; 返回 %7（i32） } define i32 @main() { ; 注意，下面出现的 %1，%2……与上面的无关，即每个函数的临时寄存器是独立的 %1 = alloca i32 %2 = alloca i32 store i32 0, i32* %1 store i32 4, i32* %2 %3 = load i32, i32* @a %4 = load i32, i32* %2 ; 调用函数 @foo ，i32 表示函数的返回值类型 ; 第一个参数是 %3（i32），第二个参数是 %4（i32），给函数的返回值命名为 %5 %5 = call i32 @foo(i32 %3, i32 %4) ret i32 %5 } 虽然上面这个文件并没有包含本实验中可能使用到的所有特性与指令，但是已经展现出了很多值得注意的地方，比如： 注释以 ; 开头 LLVM IR 是静态类型的（即在编写时每个值都有明确的类型） 局部变量的作用域是单个函数（比如 @main 中的 %1 是一个 i32* 类型的地址，而 @foo 中的 %1 是一个 i32 类型的值） 临时寄存器（或者说临时变量）拥有升序的名字（比如 @main 函数中的 %1，%2，%3） 全局变量与局部变量由前缀区分，全局变量和函数名以 @ 为前缀，局部变量以 % 为前缀 大多数指令与字面含义相同（alloca 分配内存并返回地址，load 从内存读出值，store 向内存存值，add 用于加法等） LLVM IR 的结构 如果看完下面的内容以后依然对 LLVM IR 的结构不甚了了，LLVM Programmer Manual 里的内容可能能起到帮助。 总体结构 LLVM IR 文件的基本单位称为 module（本实验中涉及到的部分均为单 module，因为本实验只涉及到单文件编译） 一个 module 中可以拥有多个顶层实体，比如 function 和 global variavle 一个 function define 中至少有一个 basicblock 每个 basicblock 中有若干 instruction，并且都以 terminator instruction 结尾 函数定义与函数声明 (Define&Delcare) 大家都学习过汇编语言，都知道在汇编层面，一个函数与一个控制语句是相似的，只不过汇编函数在跳转时有一些附加的操作。而在 LLVM 中，函数拥有更高一层的抽象。 函数定义 在上面生成的示例代码里，我们已经看到了函数定义的样子，一个最基本的main函数的定义长这样： define i32 @main() { ret i32 0 ; 返回 i32 类型的值 0 } 函数后面也可以加上参数列表，像这样： define i32 @foo(i32 %a,i32 %b) { ret i32 0 ; 返回 i32 类型的值 0 } 一个函数定义的最简单的语法形如 define + 返回值 (i32) + 函数名 (@foo) + 参数列表 ((i32 %a,i32 %b)) +函数体 ({ret i32 0}) （题外话：我们还可以在参数列表后面加上属性用来指导优化和代码生成，上面未做简化生成的main.ll中能够看到 main 函数的函数定义是 define dso_local i32 @main() #0...，这里的 #0 与main.ll中靠后的attributes #0 = ...是对应的，他们被用来给函数加上特定的标记，例如是否是能够被内联。这些内容和实验无关，你并不需要了掌握，感兴趣的话可以在 这里 进行拓展阅读。) 函数声明 除了函数定义以外，函数声明也是非常常见的，我们在一个module里，如果想要调用别的模块的函数，就需要在本模块先声明这个函数。在本实验中，要使用库函数，你可能需要用函数声明的形式在你生成的.ll文件里声明库函数的名字（我们将在下面做出示例）函数声明的结构也比较简单，就是使用declare关键词替换define，并且没有函数体。比如，下面是一些你在后续实验中将会用到的库函数的函数声明： declare i32 @getint() declare i32 @getarray(i32*) declare i32 @getch() declare void @putint(i32) declare void @putch(i32) declare void @putarray(i32,i32*) 基本块（Basic Block） 一个基本块是包含了若干个指令以及一个终结指令的代码序列。 基本块只会从终结指令退出，并且基本块的执行是原子性的，也就是说，如果基本块中的一条指令执行了，那么块内其他所有的指令也都会执行。这个约束是通过代码的语义实现的。基本块内部没有控制流，控制流是由多个基本块直接通过跳转指令实现的。 形象地讲，一个基本块中的代码是顺序执行的，且顺序执行的代码都属于一个基本块。 例如你有一份不含跳转（没有分支、循环）也没有函数调用的、只会顺序执行的代码，那么这份代码只有一个基本块。 然而，一旦在中间加入一个 if-else 语句，那么代码就会变成四个基本块：if 上面的代码仍然是顺序执行的，在一个基本块中；then 和 else 各自部分的代码也都是顺序执行的，因此各有一个基本块；if 之后的代码也是顺序执行的，也在一个基本块中。所以总共四个基本块。 指令（Instruction） 指令指的是 LLVM IR 中的非分支指令（non-branching Instruction），通常用来进行某种计算或者是访存（比如上面例子中的 add、load），这些指令并不会改变程序的控制流。 值得一提的是，call 指令也是非分支指令，因为在使用 call 调用函数时，我们并不关系被调用函数内部的具体情况（即使被调用函数内部存在的控制流），而是只关心我们传入的参数以及被调用函数的返回值，因此这并不会影响我们当前程序的控制流。 终结指令（Terminator instruction） 终结指令一定位于某个基本块的末尾（否则中间就改变了基本块内的控制流）；反过来，每个基本块的末尾也一定是一条终结指令（否则仍然是顺序执行的，基本块不应该结束）。终结指令决定了程序控制流的执行方向。例如，ret 指令会使程序的控制流返回到当前函数的调用者（可以理解为 return），br 指令表示根据标识符选择一个控制流的方向（可以理解为 if）。 下面，我们通过一个例子来介绍程序的控制流是如何通过基本块与终结指令描述的： //if.c int main() { int a = getint(); int b = getint(); int c = 0; if (a == b) { c = 5; } else { c = 10; } putint(c); return 0; } 将 if.c 导出为 LLVM IR 并且删去实验无关部分，再手动加上函数声明（我们会在后续实验中会说明要怎么做）后的代码如下所示 declare i32 @getint() declare void @putint(i32) define i32 @main() { %1 = alloca i32 %2 = alloca i32 %3 = alloca i32 %4 = alloca i32 store i32 0, i32* %1 %5 = call i32 () @getint() store i32 %5, i32* %2 %6 = call i32 () @getint() store i32 %6, i32* %3 store i32 0, i32* %4 %7 = load i32, i32* %2 %8 = load i32, i32* %3 %9 = icmp eq i32 %7, %8 br i1 %9, label %10, label %11 10: ; preds = %0 store i32 5, i32* %4 br label %12 11: ; preds = %0 store i32 10, i32* %4 br label %12 12: ; preds = %11, %10 %13 = load i32, i32* %4 call void @putint(i32 %13) ret i32 0 } 这个程序的控制流如图所示 可以看到，br指令一共在代码中出现了三次 br i1 %9, label %10, label %11 ; A br label %12 ; B br label %12 ; C 在这里，我们先介绍一下br指令的用法， br指令的语法为br + 标志位 + truelabel + falselabel，或者br + label 形如上面代码中 A 用法的转移指令叫做条件转移，如果标志位为1，程序会跳往truelabel标记的basicblock。如果标志位为0，程序会跳往falseblock标记的basicblock。比如，在代码br i1 %9, label %10, label %11中，如果%9的值为1，就会跳转往基本块%10，如果为0，就会跳转往基本块%11。 形如上面代码中B,C的用法的转移指令叫做无条件转移，他会在程序运行到此处时无条件跳转到目标基本块。在上面代码中B,C两处的代码都会无条件跳转到基本块%12。 如上图所示，%9是icmp eq指令（用来判断两个值是否相等，我们会在推荐使用的指令一节详细介绍）的结果，如果%7等于%8，那么%9的值就会为1，否则为0。这条指令对应了源代码中的if(a == b)，c=5对应了基本块%10，c=10对应了基本块%11，这两个基本块运行结束时都需要跳转到目标基本块%12执行后面的语句putint(c)以及return 0。 类型系统 本节由 LLVM Lang Ref:type-system 节选翻译而来 接下来我们介绍 LLVM IR 的类型系统。 类型系统是 LLVM IR 中最重要的部分之一，强大的类型系统在很大程度上降低了读取和分析 LLVM IR 的难度，并且可以实现一些在一般的的三地址码 IR 中难以实现的优化。LLVM IR 的类型多种多样，我们在此只介绍可能和实验关系紧密的几种。 Void Type 仅占位用，不代表任何值也不占任何空间。 比如 define void @foo(){ ret void } Integer Type 最简单的类型，代表了后面数字决定的位宽的类型，比如i1代表的就是1bit长的 integer（可以看作是 bool），i32就是32bit长的 integer, 在实验涉及内容里，我们只需要i1和i32类型。 比如 ret i32 0 br i1 %2,label %3,label %4 Label Type 标签类型，用作代码标签，比如 br i1 %9, label %10, label %11 br label %12 其他 Type 在后续的实验中，我们还会介绍 Array Type（数组部分）以及Pointer Type（变量部分），为了减轻大家第一次实验的学习压力，在此就不再详述。 说在最后 LLVM IR 是一个非常庞大的系统，这节文章仅仅能够介绍到其最重要的抽象以及和我们实验联系最紧密的抽象，你不能指望光看这一节的内容就对其完全了解，当你在后续实验中遇到问题时，你可以选择查看 Lang Ref，也可以亲自编译两份代码并看看 Clang 是怎么做的。你还可以在 github 通过 issue 的形式向助教提问（不过我们两位助教需要面对接近 300 位同学，还需要改作业，出实验，编写示例代码，时间实在不算充裕，有可能无法及时回复） "},"pre/llvm_ir_ssa.html":{"url":"pre/llvm_ir_ssa.html","title":"LLVM IR SSA 介绍","keywords":"","body":"LLVM 中的 SSA 如果看完本节以后还有感到迷惑的地方可以看下面这个视频 B 站源   油管源 在阅读本节前我们默认你已经阅读过了 LLVM IR 快速上手 一节。 为什么要介绍这些内容？ 在 LLVM IR 中，变量是以 SSA 形式存在的，为了生成正确的 LLVM IR 并实现我们的实验，对 SSA 的知识是必不可少的，LLVM IR 的代码有两种状态，分别是存取内存形式的 IR 以及带有 phi 指令的 SSA IR。因为 lab2 中已经涉及到了表达式相关的内容，所以本小节将对 SSA 进行简单的介绍，并指导大家设计合适的中间代码架构，以免实验到了后期因为设计问题出现大幅度重构。 在基础实验中，你只需要实现较简单的存取内存形式的 IR，而生成带有 phi 指令的 SSA IR 将被我们作为挑战实验发布。 SSA 介绍 静态单赋值（Static Single Assignment, SSA）是编译器中间表示中非常重要的一个概念，它是一种变量的命名约定。当程序中的每个变量都有且只有一个赋值语句时，称一个程序是 SSA 形式的。 在 LLVM IR 中，每个变量都在使用前都必须先定义，且每个变量只能被赋值一次（如果套用 C++ 的术语，就是说每个变量只能被初始化，不能被赋值），所以我们称 IR 是静态单赋值的。 举一个例子，如果想要返回 1 * 2 + 3 的值，我们下意识地就会像这样写。 %0 = mul i32 1, 2 %0 = add i32 %0, 3 ret i32 %0 很合理，不是吗？但这样写实际上是错的，因为变量 %0 被赋值了两次。我们需要修改为 %0 = mul i32 1, 2 %1 = add i32 %0, 3 ret i32 %1 SSA 的好处（拓展阅读） 对人类来说，第一种做法似乎更为直观，但是对于编译器来说，第二种做法带来的好处更多。 SSA 可以简化编译器的优化过程，譬如说，考虑这段代码： d1: y := 1 一些无关代码 d2: y := 2 一些无关代码 d3: x := y 我们很容易可以看出第一次对 y 赋值是不必要的，在对 x 赋值时使用的 y 的值时第二次赋值的结果，但是编译器必须要经过一个定义可达性（Reaching definition）分析才能做出判断。编译器是怎么分析呢？首先我们先介绍几个概念（这些概念将会在我们课程的后半部分出现，我们在这里先 look ahead 一下，不完全理解也不影响实验的进行）： 定义：对变量 x 进行定义的意思是在某处会/可能给 x 进行赋值，比如上面的 d1 处就是一个对 y 的定义。 kill：当一个变量有了新的定义后，旧有的定义就会被 kill，在上面的语句中 d2 就 kill 了 d1 中对 y 的定义 定义到达某点：定义 p 到达某点 q 的意思是存在一条路径，沿着这条路径行进，p 在到达到点 q 之前不会被 kill。 reaching definition：a 是 b 的 reaching definition 的意思是存在一条从 a 到达 b 的路径，沿着这条路径走可以自然得到 a 要赋值的变量的值，而不需要额外的信息。 按照上面的写法，d1 便不再是 d3 的 reaching definition, 因为 d2 使它不再可能被到达。 对我们来说，这件事情是一目了然的，但是如果控制流再复杂一点，对于编译器来说，它便无法确切知道 d3 的 reaching definition 是 d1 或者 d2 了，也不清楚 d1 和 d2 到底是谁 kill 了谁。但是，如果我们的代码是 SSA 形式的，那它就会长成这样。 d1: y1 := 1 一些无关代码 d2: y2 := 2 一些无关代码 d3: x := y2 编译器很容易就能够发现 x 是由 y2 赋值得到，而 y2 被赋值了 2，且 x 和 y2 都只能被赋值一次，显然得到 x 的值的路径就是唯一确定的，d2 就是 d3 的 reaching definition。而这样的信息，在编译器想要进行优化时会起到很大的作用。 SSA 带来的麻烦事 假设你想用 IR 写一个用循环实现的 factorial 函数： int factorial(int val) { int temp = 1; for (int i = 2; i 按照 C 语言的思路，我们可能大概想这样写 然而我们会发现 %temp 和 %i 被多次赋值了，这并不合法。 怎么办？ plan a —— phi phi 在基础实验中不要求生成，后面的挑战实验中的 mem2reg 的内容就是将 load/store 形式的 IR 转换为 phi 形式的 SSA。 在 clang -O1 选项下生成这个函数的 .ll 格式的文件，我们会发现生成的代码大概长这样： define dso_local i32 @factorial(i32 %0) local_unnamed_addr #0 { %2 = icmp slt i32 %0, 2 br i1 %2, label %3, label %5 3: ; preds = %5, %1 %4 = phi i32 [ 1, %1 ], [ %8, %5 ] ; 如果是从块 %1 来的，那么值就是 1，如果是从 ret i32 %4 ; 块 %5 来的，那么值就是 %8 的值 5: ; preds = %1, %5 %6 = phi i32 [ %9, %5 ], [ 2, %1 ] %7 = phi i32 [ %8, %5 ], [ 1, %1 ] %8 = mul nsw i32 %6, %7 %9 = add nuw i32 %6, 1 %10 = icmp eq i32 %6, %0 br i1 %10, label %3, label %5 } phi 指令的语法是 = phi [, ], [, ] ... 这个指令能够根据进入当前基本块之前执行的是哪一个基本块的代码来选择一个变量的值，有了 phi 以后我们的代码就变成了 这样的话，每个变量就只被赋值一次，并且实现了循环递增的效果。 在这里你也可以发现：SSA 要求的是在静态，即仅从代码文本层面可以看出的单一赋值，而非运行时只会被赋值一次。 plan b —— alloca、load 与 store 前面铺垫了那么长时间，就是为了介绍 alloca，load 与store 三条指令以及他们的作用的。 在 -O0 选项下生成这个函数的 .ll 格式的文件，我们会发现生成的代码大概长这样 define dso_local i32 @factorial(i32 %0) #0 { %2 = alloca i32, align 4 %3 = alloca i32, align 4 %4 = alloca i32, align 4 store i32 %0, i32* %2, align 4 store i32 1, i32* %3, align 4 store i32 2, i32* %4, align 4 br label %5 5: %6 = load i32, i32* %4, align 4 %7 = load i32, i32* %2, align 4 %8 = icmp sle i32 %6, %7 br i1 %8, label %9, label %16 9: %10 = load i32, i32* %4, align 4 %11 = load i32, i32* %3, align 4 %12 = mul nsw i32 %11, %10 store i32 %12, i32* %3, align 4 br label %13 13: %14 = load i32, i32* %4, align 4 %15 = add nsw i32 %14, 1 store i32 %15, i32* %4, align 4 br label %5 16: %17 = load i32, i32* %3, align 4 ret i32 %17 } alloca 指令的作用是在当前执行的函数的栈帧上分配内存并返回一个指向这片内存的指针，当函数返回时内存会被自动释放（一般是改变栈指针）。 不难看出，这里的 .ll 文件所展示的 IR 中对一些局部变量存在多次 store 操作，但这些局部变量都是存放在内存中的，而非直接作为 LLVM IR 的一个虚拟寄存器被赋值。实际上，这是借助 LLVM IR 中只要求虚拟寄存器是 SSA 形式，而内存不要求是 SSA 形式的特点开了个后门来妥协，前端可以直接把局部变量分配到内存当中，放在内存里的变量不需要遵循 SSA 形式，可以经受多次定义。构造 SSA 的算法比较复杂，而且需要各种复杂的数据结构，这些因素导致在前端直接生成 SSA 形式的 IR 时非常麻烦。 基于上述的 trick，前端能够直接将变量按照栈的方式分配到内存当中，并且这个内存里的变量不需要遵循 SSA 形式，可以被多次定义，从而避免了构造 phi 指令产生的大量开销。 在 LLVM 中，所有的内存访问都需要显式地调用 load/store 指令。要说明的是，LLVM 中并没有给出“取地址”的操作符。以上面生成的代码中的 %3 为例，我们能在这些地方发现它 entry: %3 = alloca i32, align 4 ... 9: ... %11 = load i32, i32* %3, align 4 ... store i32 %12, i32* %3, align 4 变量 %3 通过 alloca 声明，分配了一个 i32 大小的空间，这里 %3 的类型为 i32*，也就是说，%3 代表的是这段空间的地址，load 将 %3 所指向空间的内容读取出来，而 store 将新的值写入 %3 指向的空间。alloca 分配的栈变量可以进行多次存取，因此，通过 alloca、load 和 store，我们避免了 phi 指令的使用。 划重点，这种生成存取内存的 LLVM IR 的方法有四个特点： 每个可变变量都变为了栈上分配的空间（每个变量都变成了一条 alloca 指令） 每次对变量的读都变成了从内存空间中的一次读（每次读取一个变量都变成了通过 load 对变量所在内存的读） 每次对变量的写都变成了对内存的一次写（每次更新一个变量的值都变成了通过 store 对变量所在内存的写） 获取变量的地址等价于获取内存的地址 不难发现，这种方法虽然避免了 phi 的出现，但是每次变量的存取都变成了访问内存，这会导致严重的性能问题。所幸，正如我们之前所说的，LLVM 提供了一个叫做 mem2reg 的解决方案，它能够把 alloca 指令分配的内存变量转化为 SSA 形式的 LLVM IR 虚拟寄存器变量，并且在合适的地方插入 phi 指令。 LLVM 官方非常支持使用上述 alloca + mem2reg 技术，clang 默认不开优化生成的就是存取内存形式的 IR。alloca 技术可以把前端从繁琐的 SSA 构造工作中解脱出来，而 mem2reg 则可以极其快速地生成 SSA 形式。这两者的结合大大提高了编译的效率。 在基础实验中，你只需要实现较简单的存取内存形式的 IR，而生成带有 phi 指令的 SSA IR 将被我们作为挑战实验发布。 "},"pre/design_hints.html":{"url":"pre/design_hints.html","title":"LLVM 架构中最重要的概念，以及编译器设计的提示","keywords":"","body":"LLVM 架构中最重要的概念，以及编译器设计的提示 本节假设你已经阅读过本章节中的其他所有章节，并且具有一定的面向对象知识。 你第一次看到本节的时间应该是 lab2 刚开始的时候，如果你已经通过了 lab1——无论是递归下降还是使用工具分析。 那么你应该已经对这个实验具体要做什么有了较为直观的感受。 之前的几节介绍的是以文本形式存储的 .ll 形式的 LLVM IR, 这节我们将介绍 LLVM IR 在内存中的存储方式——也就是在程序运行时 LLVM 是怎么保存和维护 LLVM IR 的。并籍此给出一些实现编译器的建议。重构你的代码的时候到了（笑） 注：因为我们的实验只需要完成最简单的功能，所以你大可以自己设计自己的代码架构，只要最后通过测试点即可。 我们强烈建议在向下看之前先大致浏览一遍 LLVM 中核心类的层次结构参考 最重要的概念：Value, Use, User 这是我们学习并设计自己的翻译到 LLVM IR 的编译器时需要认识的最重要的概念之一。 一切皆 Value 这是个夸张的说法，不过在 LLVM 架构中，的确几乎所有的东西都是一个 Value，这里有张继承关系图。（src:https://llvm.org/doxygen/classllvm_1_1Value.html） 我们重点关注这么几项 BasicBlock，Argument，User 都继承了 Value 类 Constant 和 Instruction 继承了 User 图中没有 Function 类，但实际上 Function 类通过多重继承继承了 Constant 类，所以 Function 也是 Value 和 User BasicBlock 表示的是基本块类，Arugument 表示的是函数的形参，Constant 表示的是形如 i32 4 的常量，Instruction 表示的是形如 add i32 %a,%b 的指令 Value 是一个非常基础的基类，一个继承于 Value 的子类表示它的结果可以被其他地方使用。 一个继承于 User 的类表示它会使用一个或多个 Value 对象 根据 Value 与 User 之间的关系，还可以引申出 use-def 链和 def-use 链这两个概念。use-def 链是指被某个 User 使用的 Value 列表，def-use 链是使用某个 Value 的 User 列表。实际上，LLVM 中还定义了一个 Use 类，Use 就是上述的使用关系中的一个边。 下面是从 LLVM 2.0.0 中节选的代码（新版本的太复杂了，增加了理解难度） class Value { // 无关代码 private: Use *UseList; } class User : public Value { // 无关代码 protected: Use *OperandList; unsigned NumOperands; } class Use { // 无关代码 Use *Next, **Prev; Value *Val; User *U; } class Value 中的 UseList 保存了使用了这个 Value 的 User 列表，这对应着 def-use 关系。 class User 中的 OperandList 保存了这个 User 使用的 Value 的列表，这对应着 use-def 关系。 class Use 中的 Value, User 的引用，维护了这条边的两个结点以及使用和被使用的关系，从 User 能够通过 OperandList 找到这个 User 使用的 Value, 从 Value 也能找到对应的使用这个 Value 的 User。 以一段手写的 .ll 代码为例 define dso_local i32 @main(){ %x0 = add i32 5, 0 %x1 = add i32 5, %x0 ret i32 %x1 } 其在内存中的存储形式大概是这样的 %x0 是一个 Instruction 实例，它的 OperandList 里有两个值，一个是 Constant 的实例 5，另一个是 Constant 的实例 0； %x1 是一个 Instruction 实例，它的 OperandList 里有两个值，一个是 Constant 的实例 5，另一个是 Instruction 的实例 %x0； ret 是一个 Instruction 实例，它的 OperandList 里有一个值，是 Instruction 的实例 %x0。 需要注意的是：clang 默认生成的虚拟寄存器是按数字顺序命名的，LLVM 限制了所有数字命名的虚拟寄存器必须严格地从 0 开始递增，且每个函数参数和基本块都会占用一个编号。如果你不能确定怎样用数字命名虚拟寄存器，请使用字符串命名虚拟寄存器。 下面的 LLVM IR 中给出了一些 lli 解释执行成功或失败的情况： ; 解释执行成功 define dso_local i32 @main(){ %1 = sub i32 0, 15 %2 = sub i32 0, %1 %3 = add i32 0, %2 ret i32 %3 } ; 解释执行成功 define dso_local i32 @main(){ %1 = sub i32 0, 15 %x = sub i32 0, %1 %2 = add i32 0, %x ret i32 %2 } ; 解释执行失败 ; lli: test.ll:2:5: error: instruction expected to be numbered '%1' ; %0 = sub i32 0, 15 define dso_local i32 @main(){ %0 = sub i32 0, 15 %1 = sub i32 0, %0 %2 = add i32 0, %1 ret i32 %2 } ; 解释执行成功 define dso_local i32 @main(){ _entry: ; 显式地给基本块指定一个名称 %0 = sub i32 0, 15 %1 = sub i32 0, %0 %2 = add i32 0, %1 ret i32 %2 } "},"pre/suggested_insts.html":{"url":"pre/suggested_insts.html","title":"推荐指令","keywords":"","body":"推荐使用的指令 本节默认你已经掌握了一定的LLVM相关的知识。 本节介绍了一些我们认为有用的 LLVM IR 的指令以及其简化的用法（比如load指令的完整用法为 ` = load [volatile] , * [, align ][, !nontemporal !][, !invariant.load !][, !invariant.group !][, !nonnull !][, !dereferenceable !][, !dereferenceable_or_null !][, !align !][, !noundef !****） 当然，你可以不局限我们所介绍的这些指令。在实验中，我们只要求你编译到正确的 LLVM IR 即可，因此你可以自己在 LLVM Lang Ref 里选择指令自己需要的指令用在生成的代码中。 只要通过了测试点，我们就认为你所编写的编译器是正确的。 instructions llvm ir usage intro add = add , / sub = sub , / mul = mul , / sdiv = sdiv , 有符号除法 icmp = icmp , 比较指令 and = and , 与 or = or , 或 call = call [ret attrs] () 函数调用 alloca = alloca 分配内存 load = load , * 读取内存 store store , * 写内存 getelementptr = getelementptr , * {, [inrange] }* = getelementptr inbounds , * {, [inrange] }* 计算目标元素的位置（仅计算） phi = phi [fast-math-flags] [ , ], ... zext..to = zext to 类型转换，将 ty的value的type转换为ty2 terminator insts llvm ir usage intro br br i1 , label , label br label 改变控制流 ret ret ,ret void 退出当前函数，并返回值（可选） "},"pre/pre.html":{"url":"pre/pre.html","title":"pre","keywords":"","body":"PRE pre 的目的是让大家提前熟悉本学期实验中经常会用到的一些工具，我们也知道实验的内容量看起来很吓人，但是实际上需要你动手编写的代码数量并不特别多。万事开头难，相信认真阅读学习了 pre 内容的你一定会在后面的实验中游刃有余。 思考： 在 LLVM IR 中，为什么不能将无条件跳转指令删除，直接接到目标基本块的开头？在什么情况下能够这么做？ 怎么用跳转指令实现循环控制流？（提示：往回跳） 怎么用跳转指令实现短路求值？ LLVM IR 和真正的汇编语言有什么区别？LLVM IR 和常见的高级语言（比如 C、Java）有什么区别？ 在使用解析器生成工具时，怎样跳过代码中的注释？ ANTLR Visitor 模式下怎样进行方法间的传值？ "},"pre/generator/generator.html":{"url":"pre/generator/generator.html","title":"（阅读）flex/bison/ANTLR","keywords":"","body":"flex/bison/ANTLR 简介 在后续完成一个完整的编译器的实验中，我们允许你使用解析器生成工具来自动生成编译器的前端词法分析部分和语法分析部分。 如果你打算手动实现词法分析和语法分析，可以跳过此节。 这部分会涉及到后面的知识，看不懂其中的一些地方是正常的。 本节的语法解析部分将会使用生成器生成用于解析算术表达式的代码，其示例文法如下： expr -> term | expr '+' term | expr '-' term term -> factor | term '*' factor | term '/' factor factor -> '(' expr ')' | number number -> [0-9]+ | [0-9]+ '.' [0-9]* | [0-9]* '.' [0-9]+ "},"pre/generator/flex.html":{"url":"pre/generator/flex.html","title":"flex","keywords":"","body":"flex flex（the Fast Lexical Analyzer Generator）是 Lawrence Berkeley 实验室研发的一款词法分析程序的生成工具，它的前身是我们在课程中学到的 Lex。 安装 flex flex 的最新版本是 2.6.4，发布于 2017 年 5 月 6 日。 Ubuntu $ sudo apt install flex MacOS $ brew install flex Homebrew 中 flex 的最新版本是 2.6.4，MacOS 中自带的 flex 版本是 2.5.35，需要手动指定环境变量以使用较新的 flex。 $ echo 'export PATH=\"/usr/local/opt/flex/bin:$PATH\"' >> ~/.bash_profile 注意 如果你使用的是 zsh 或者其他种类的 shell，需要自行将环境变量的配置添加到对应的配置文件中，如 .zshrc 等。 Windows & other Linux 自行探索 flex 的使用 flex 源文件的扩展名为 .l，分为「声明」、「规则」、「用户子程序」三部分。下面我们以生成一个用于统计文本中单词和字母个数的词法分析器的例子来介绍 flex 的使用。 生成 C 代码 flex 会读取一个 *.l 或者 *.lex 文件里的词法规则，并将生成的词法分析器代码写入 lex.yy.c。 「声明」部分的代码用%{ 和 %} 来包裹，这些代码会被 flex 原样复制到 lex.yy.c 中，你可以在这里书写声明和定义。如下是一个声明部分的示例： /* word_char_counter.l */ /* 在这里我们要统计字符数和单词数，因此需要声明这两个统计变量 */ %{ #include int chars = 0; int words = 0; %} 「规则」部分的代码用 %% 和 %% 来包裹，你可以使用正则表达式来编写模式，在正则表达式后面编写一段 C 代码，指明匹配到相应的模式后所要完成的动作。如下是一个规则部分的示例： /* word_char_counter.l */ /* 遇到匹配的模式则累加对应的统计变量 */ %% [a-zA-Z]+ { chars += strlen(yytext); words++; } . { } %% 在规则部分中，标识符 yytext 是一个指针，指向匹配到的输入字符串。 如果要将 flex 与 bison（后面会介绍的用来生成语法解析器的工具）或其他你自行编写的程序配合使用，那么你可以不写「用户子程序」部分；否则，你就需要通过编写「用户子程序」来使用词法解析得到的信息。 /* word_char_counter.l */ int main(int argc, char **argv) { yylex(); printf(\"I found %d words of %d chars.\\n\", words, chars); return 0; } 其中 yylex() 是 flex 生成的函数，它会对输入进行词法分析并完成制定的动作（默认读取 stdin）。 写完词法规则后，可以使用 flex 生成对应的 C 代码文件： $ flex word_char_counter.l $ gcc lex.yy.c -o word_char_counter 但是如果你像这样直接进行编译，会出现下面这样的报错信息： /usr/bin/ld: /tmp/cc1qil64.o: in function `yylex': lex.yy.c:(.text+0x4b8): undefined reference to `yywrap' /usr/bin/ld: /tmp/cc1qil64.o: in function `input': lex.yy.c:(.text+0x10c7): undefined reference to `yywrap' collect2: error: ld returned 1 exit status 观察报错信息会发现它说找不到 yywrap() 这个函数的位置。这是因为在 flex 2.5.4 版本之后，当程序扫描到 EOF 时会调用 yywrap() 函数来判断是否还有其他的输入，如果 yywrap() 返回 0，则程序用来读取输入的指针会在 yywrap() 被重定向到另一个输入并且继续读取；反之，如果 yywrap() 返回 1，则说明没有其他输入。 在这里，你可以链接 fl 库，调用其中默认会返回 1 的 yywrap() 函数（只需要读取一个输入文件或 stdin），即使用 gcc lex.yy.c -o word_char_counter -lfl 。或者也可以在源文件的开头加上一行 %option noyywrap，表示不调用 yywrap()，从而解决链接错误。 $ ./word_car_counter Hello, flex. ^D I found 2 words of 9 chars. 生成 C++ 代码 编写 flex 源文件如下： /* word_char_counter_cpp.l */ %option c++ %option noyywrap %{ #include int chars = 0; int words = 0; %} %% [a-zA-Z]+ { chars += strlen(yytext); words++; } . { } %% int main(int argc, char **argv) { FlexLexer* lexer = new yyFlexLexer(); lexer->yylex(); std::cout 使用 flex 生成 C++ 代码有两种方式，一种是在源文件中加入 %option c++，另一种是在生成时增加选项 -+，如 flex word_char_counter_cpp.l -+。 写完词法规则后，可以使用 flex 生成对应的 C++ 代码文件： $ flex word_char_counter_cpp.l $ g++ lex.yy.cc -o word_char_counter_cpp 运行编译后的程序，表现和生成 C 代码时编译出的程序结果一致。 $ ./word_car_counter_cpp Hello, flex. ^D I found 2 words of 9 chars. "},"pre/generator/bison.html":{"url":"pre/generator/bison.html","title":"bison","keywords":"","body":"bison bison 是一款语法分析程序的生成工具，其前身为 yacc。yacc 由贝尔实验室的 S.C.Johnson 基于 LR 分析技术开发的解析器，于 1975 ～ 1978 年写成。大约在 1985 年，UC Berkeley 的研究生 Bob Corbett 使用改进的内部算法实现了伯克利 yacc，接着来自 FSF 的 Richard Stallman 改写了伯克利 yacc，向其中添加了很多特性并将其用于 GNU 项目，这便形成了今天的 GNU bison。 安装 bison bison 的最新版本是 3.7.90，发布于 2021 年 8 月 13 日。 Ubuntu Ubuntu 20.04 官方源中的 bison 的最新版本是 3.5.1，Ubuntu 18.04 官方源中的 bison 的最新版本是 3.0.4，如果你需要安装最新版本的 bison，请自行探索。 $ sudo apt install bison MacOS $ brew install bison Homebrew 中 bison 的最新版本是 3.8.1，MacOS 中自带的 bison 版本是 2.3，需要手动指定环境变量以使用较新的 bison。 $ echo 'export PATH=\"/usr/local/opt/bison/bin:$PATH\"' >> ~/.bash_profile 注意 如果你使用的是 zsh 或者其他种类的 shell，需要自行将环境变量的配置添加到对应的配置文件中，如 .zshrc 等。 Windows & other Linux 自行探索 bison 的使用 bison 通常与 flex 配合使用（flex 负责解析词法，bison 负责解析语法）。通常的做法是先使用 flex 对输入文本进行词法分析并生成 token 流，然后由 bison 读取用户提供的语法规则，生成用于解析 token 流的代码，再由这部分生成的代码来解析 token 流。 bison 源文件的扩展名为 .y，分为「声明」、「定义」、「规则」、「用户子程序」四部分。下面以一个四则运算计算器为示例介绍 bison 和 flex 的配合使用，其文法如下（与本章开头的文法相同）： expr -> term | expr '+' term | expr '-' term term -> factor | term '*' factor | term '/' factor factor -> '(' expr ')' | number number -> [0-9]+ | [0-9]+ '.' [0-9]* | [0-9]* '.' [0-9]+ 生成 C 代码 首先编写 flex 源文件 calc.l 如下： /* calc.l */ %option noyywrap %{ #include \"calc.tab.h\" %} /* 将不同的符号解析成不同的 token */ %% \\( { return LPAREN; } \\) { return RPAREN; } \"+\"|\"-\" { yylval.op = yytext[0]; return ADDOP; } \"*\"|\"/\" { yylval.op = yytext[0]; return MULOP; } [0-9]+|[0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+ { yylval.num = atof(yytext); return NUMBER; } \" \"|\\t { } \\r\\n|\\n|\\r { return RET; } %% LPAREN, RPAREN, ADDOP 等 token 的名称会定义在 bison 源文件的「定义」部分中。bison 生成语法分析器代码后，这些符号会被写入 calc.tab.h 文件。 yylval 是 flex 的全局变量，用于在 flex 和 bison 之间传值，其默认类型为 int。这里的 yylval 的类型为 union { char op; double num; }，表示要么是一个 char，要么是一个 num，同样定义在 bison 源文件的「定义」部分中。 接下来要编写 bison 的源文件 calc.y。 「声明」部分的代码用 %{ 和 %} 包裹，会被 bison 原样复制到生成的代码中，你可以在这里书写声明。如下是一个「声明」部分的示例： /* calc.y */ %{ #include int yylex(void); void yyerror(const char *s); %} 这里声明了 yylex() 和 yyerror(const char *) 两个函数，其中 yylex 函数会由 flex 生成，yyerror 需要在最后的「用户子程序」部分定义。 「定义」部分用于定义一些 bison 中专有的变量、类型等。 /* calc.y */ %union { char op; double num; } %token RET %token NUMBER %token ADDOP MULOP LPAREN RPAREN %type line expr term factor 这里包括了对 token 的定义、对部分 token 类型的定义、对非终结符类型的定义以及 对 yylval 类型的定义。 「规则」部分的代码用 %% 和 %% 包裹，在这里你可以编写一系列语法规则。你需要使用 : 代表一个 BNF 文法中的 -> 或 ::=；同一非终结符的不同规则使用 | 分隔；使用 ; 表示一个非终结符的规则的结束。每条规则的后面可以插入一段 C 代码，当该规则被应用时，这段代码会被执行。 bison 会将「规则」部分中第一个规则左部的非终结符作为语法的起始符号。 「规则」中的非终结符都不需要预先定义，因为一个符号是否为非终结符可以由 bison 通过所有规则的左部推断出来。对于终结符，单字符的终结符可以直接使用单引号包裹，多字符的终结符则需要在定义部分中定义，由 bison 为其分配一个编号。 下面将已有的文法翻译成 bison 源文件： /* calc.y */ %% calculator : calculator line { } | { } line : expr RET { printf(\" = %f\\n\", $1); } expr : term { {% math %} = $1; } | expr ADDOP term { switch ($2) { case '+': {% endmath %} = $1 + $3; break; case '-': {% math %} = $1 - $3; break; } } term : factor { {% endmath %} = $1; } | term MULOP factor { switch ($2) { case '*': {% math %} = $1 * $3; break; case '/': {% endmath %} = $1 / $3; break; } } factor : LPAREN expr RPAREN { {% math %} = $2; } | NUMBER { {% endmath %} = $1; } %% 在这里，我们对文法做了些许改动，使得生成的代码可以识别出换行符后便输出这一行的运算结果，从而进行多次运算。 $$ 表示规则左部非终结符的值； $1, $2, ..., $n 表示规则右部每一个符号的值。如果符号是终结符，它的值就是 calc.l 中对应的 yylval 的值。 「用户子程序」部分由自己实现，这里实现了解析错误时用于报错的 yyerror 函数。 /* calc.y */ void yyerror(const char *s) { fprintf(stderr, \"%s\\n\", s); } 代码全部编写完成后，分别使用 flex 和 bison 生成词法分析程序和语法分析程序。flex 生成的词法分析程序文件是 lex.yy.c，bison 生成的语法分析程序文件包括 calc.tab.c, calc.tab.h。 $ flex calc.l $ bison -d calc.y # -d 选项表示同时生成头文件，方便和 flex 联动 下面编写一个驱动程序，调用 bison 生成的 yyparse() 函数来解析输入的字符串。 /* driver.c */ int yyparse(); int main() { yyparse(); return 0; } 将这些文件放到一起编译并生成二进制文件： $ gcc lex.yy.c calc.tab.c driver.c -o calc 调用二进制文件就可以得到一个简单的计算器应用： $ ./calc 1919 * 810 = 1554390.000000 123.456 - 654.321 = -530.865000 4. * .6 = 2.400000 1 + 1 * 4 = 5.000000 (5 - 1) * 4 = 16.000000 6 * 0 - syntax error 生成 C++ 代码 详见 官方文档 "},"pre/generator/ANTLR.html":{"url":"pre/generator/ANTLR.html","title":"ANTLR","keywords":"","body":"ANTLR ANTLR（ANother Tool for Language Recognition）是一款强大的语法分析器生成工具，基于 LL(*) 分析技术。ANTLR 可以通过解析用户自定义的上下文无关文法，自动生成词法分析器、语法分析器。 ANTLR 支持多种代码生成目标，包括 Java、C++、C#、Python、Go、JavaScript、Swift 等。 安装 ANTLR ANTLR 是用 Java 编写的，安装 ANTLR 只需要从 ANTLR 官网 下载最新的 jar 包，并放在合适的位置。该 jar 包中包含 ANTLR 工具本体和运行 ANTLR 生成的 java 代码所需的运行时库。如果你需要运行 ANTLR 生成的其他语言的代码，需要从官网额外下载对应语言的运行时库。 从官网下载最新的 jar 包，放在合适的位置。如： $ mkdir antlr && cd antlr $ curl -O https://www.antlr.org/download/antlr-4.9.2-complete.jar 你可以直接通过 Java 执行 jar 包的方式运行 ANTLR，如： $ java -jar antlr-4.9.2-complete.jar ANTLR 的语法文件：.g4 ANTLR 源文件的扩展名为 .g4。ANTLR 会读入 .g4 文件，并生成对应的词法分析程序和语法分析程序。 在 .g4 文件的开头，你需要给文件中定义的语法起个名字，这个名字必须和文件名相同。 // calc.g4 grammar calc; ANTLR 中的注释和 C 语言相同，都是用 // 与 /**/ 作为注释符号。 首先定义词法解析规则，ANTLR 约定词法解析规则以大写字母开头。和 bison 类似。ANTLR 使用 : 代表 BNF 文法中的 -> 或 ::=；同一终结符/非终结符的不同规则使用 | 分隔；使用 ; 表示一条终结符/非终结符的规则的结束。 // calc.g4 LPAREN: '('; RPAREN: ')'; ADD: '+'; SUB: '-'; MUL: '*'; DIV: '/'; NUMBER: [0-9]+ | [0-9]+ '.' [0-9]* | [0-9]* '.' [0-9]+; RET: '\\r\\n' | '\\n' | '\\r'; WHITE_SPACE: [ \\t] -> skip; // -> skip 表示解析时跳过该规则 然后定义语法解析规则。ANTLR 约定语法解析规则以小写字母开头，默认将第一个语法规则左部的非终结符作为语法的起始符号。 // calc.g4 calculator: line*; line: expr RET; expr: expr ADD term | expr SUB term | term; term: factor | term MUL factor | term DIV factor; factor: LPAREN expr RPAREN | NUMBER; 前面提到，ANTLR 基于 LL(*) 分析技术，这是一种自顶向下的分析方法。在课程中我们会学到，自顶向下的分析方法不能处理具有左递归的文法。但在 ANTLR 的实现中有一些改进：如果直接左递归规则中存在一个非左递归的选项，那么它仍然是可以处理的，如 expr: expr ADD term | expr SUB term | term; 中的选项 term，但是 ANTLR 仍然不能处理没有非左递归选项的左递归规则以及间接左递归。 ANTLR 隐式地允许指定运算符优先级，规则中排在前面的选项优先级比后面的选项优先级更高，所以你甚至可以把文法改写成这样： // calc.g4 calculator: line*; line: expr RET; expr: expr MUL expr | expr DIV expr | expr ADD expr | expr SUB expr | NUMBER | LPAREN expr RPAREN; ANTLR 官方提供了一些常见语言的语法规则文件，见 https://github.com/antlr/grammars-v4 使用 ANTLR 生成代码 编写完成 ANTLR 的语法文件后，将 .g4 文件作为一项参数，运行 ANTLR，可生成对应的解析程序，并且默认生成 Java 代码。 $ java -jar antlr-4.9.2-complete.jar calc.g4 如果你需要生成其他语言的代码，可以在运行 ANTLR 时通过 -Dlanguage= 来指定，如： # 生成 C++ 代码 $ java -jar antlr-4.9.2-complete.jar -Dlanguage=Cpp calc.g4 ANTLR 在完成语法分析后，会生成一棵程序对应的语法树。例如对于如下字符串： 1919 * 810.114 (5 - 1) * 4 生成的语法树如图所示： 遍历语法树 Listener 模式和 Visitor 模式 ANTLR 提供了 Listener 和 Visitor 两种模式来完成语法树的遍历，默认生成的是 Listener 模式的代码，如果要生成 Vistor 模式的代码，需要运行选项中加上 -visitor，如果要关闭生成 Listener 模式的代码，需要运行选项中加上 -no-listener。 下面以生成 Java 代码为例进行介绍。 上面的例子中，ANTLR 生成的文件包括 calc.interp、calc.tokens、calcBaseListener.java、calcLexer.interp、calcLexer.java、calcLexer.tokens、calcListener.java、calcParser.java（如果开启了 Visitor 模式，还包括 calcBaseVisitor.java 和 calcVisitor.java）。calcLexer.java 是词法分析程序，calcParser.java 是语法分析程序。*.tokens 文件中包括一系列 token 的名称和对应的值，用于词法分析和语法分析。*.interp 包含一些 ANTLR 内置的解释器需要的数据，用于 IDE 调试语法。 我们重点关注 calcListener.java 和 calcVisitor.java，它们是 Listener 模式和 Visitor 模式的接口，calcBaseListener.java 和 calcBaseVisitor.java 分别是对应接口的默认实现。 在使用 ANTLR 生成的代码时，你需要定义一个类继承 BaseListener 或 BaseVisitor，在其中重写遍历到每个节点时所调用的方法，完成从语法树翻译到 IR 的翻译工作。 Listener 模式中为每个语法树节点定义了一个 enterXXX 方法和一个 exitXXX 方法，如 void enterExpr(calcParser.ExprContext ctx) 和 void exitExpr(calcParser.ExprContext ctx)。遍历语法树时，程序会自动遍历所有节点，遍历到一个节点时调用 enter 方法，离开一个节点时调用 exit 方法，你需要在 enter 和 exit 方法中实现翻译工作。 Vistor 模式中为每个语法树节点定义了返回值类型为泛型的 visitXXX 方法，如 T visitExpr(calcParser.ExprContext ctx)。遍历语法树时，你需要调用一个 Visitor 对象的 visit 方法遍历语法树的根节点，visit 方法会根据传入的节点类型调用对应的 visitXXX 方法，你需要在 visitXXX 方法中实现翻译工作。在翻译工作中，你可以继续调用 visit 方法来手动遍历语法树中的其他节点。 我们可以发现：Listener 模式中方法没有返回值，而 Vistor 模式中方法的返回值是一个泛型，类型是统一的，并且两种模式中的方法都不支持传参。在我们需要手动操纵返回值和参数时，可以定义一些属性用于传递变量。 Listener 模式中会按顺序恰好遍历每个节点一次，进入或者退出一个节点的时候调用你实现的对应方法。而 Vistor 模式中对树的遍历是可控的，你可以遍历时跳过某些节点或重复遍历一些节点，因此在翻译时推荐使用 Visitor 模式。 运行 ANTLR 生成的代码 运行 ANTLR 生成的 Java 代码 为了运行 ANTLR 生成的代码，你需要在 CLASSPATH 中加入 ANTLR 的运行时库，Java 版本的运行时库包含在之前下载的 antlr-4.9.2-complete.jar 包中。 编写打印语法树的代码如下： // Main.java import org.antlr.v4.runtime.tree.ParseTree; import org.antlr.v4.runtime.CharStream; import org.antlr.v4.runtime.CharStreams; import org.antlr.v4.runtime.CommonTokenStream; public class Main { public static void main(String[] args) { String input = \"1919 * 810\\n\" + \"123.456 - 654.321\\n\" + \"4. * .6\\n\" + \"1 + 1 * 4\\n\" + \"(5 - 1) * 4\\n\"; CharStream inputStream = CharStreams.fromString(input); // 获取输入流 calcLexer lexer = new calcLexer(inputStream); CommonTokenStream tokenStream = new CommonTokenStream(lexer); // 词法分析获取 token 流 calcParser parser = new calcParser(tokenStream); ParseTree tree = parser.calculator(); // 获取语法树的根节点 System.out.println(tree.toStringTree(parser)); // 打印字符串形式的语法树 } } 在 CLASSPATH 中加入了 ANTLR 的运行时库后，你可以直接使用 javac 来编译 Main.java。 $ echo $CLASSPATH .:/usr/local/lib/antlr-4.9.2-complete.jar: $ ls Main.java calc.tokens calcBaseVisitor.java calcLexer.java calcListener.java calcVisitor.java calc.interp calcBaseListener.java calcLexer.interp calcLexer.tokens calcParser.java calculator.iml $ javac Main.java 运行程序，打印出字符串形式的语法树。 $ java Main (calculator (line (expr (term (term (factor 1919)) * (factor 810))) \\n) (line (expr (expr (term (factor 123.456))) - (term (factor 654.321))) \\n) (line (expr (term (term (factor 4.)) * (factor .6))) \\n) (line (expr (expr (term (factor 1))) + (term (term (factor 1)) * (factor 4))) \\n) (line (expr (term (term (factor ( (expr (expr (term (factor 5))) - (term (factor 1))) ))) * (factor 4))) \\n)) 在 IDE 中的运行可以自行查阅相关资料 运行 ANTLR 生成的 C++ 代码 在官网下载 ANTLR C++ Runtime 源文件，将 runtime/src/ 下的代码复制到你认为合适的位置。 编写打印语法树的代码如下： // main.cpp #include \"calcLexer.h\" #include \"calcParser.h\" #include using namespace std; using namespace antlr4; int main(int argc, char *argv[]) { string input(\"1919 * 810\\n123.456 - 654.321\\n4. * .6\\n1 + 1 * 4\\n(5 - 1) * 4\\n\"); ANTLRInputStream inputStream(input); calcLexer lexer(&inputStream); CommonTokenStream tokenStream(&lexer); calcParser parser(&tokenStream); tree::ParseTree *tree = parser.calculator(); cout toStringTree(&parser) 编写 CMakeLists.txt 如下： # CMakeLists.txt project(antlr-calculator CXX) cmake_minimum_required(VERSION 3.1) file(GLOB_RECURSE DIR_SRC \"src/*.cpp\") file(GLOB_RECURSE DIR_LIB_SRC \"third_party/*.cpp\") include_directories(src/) include_directories(third_party/antlr-runtime) add_executable(main ${DIR_SRC} ${DIR_LIB_SRC}) 使用 cmake 来构建项目： $ mkdir build && cd build $ cmake .. $ make 运行程序，打印出字符串形式的语法树。 $ ./main (calculator (line (expr (term (term (factor 1919)) * (factor 810))) \\n) (line (expr (expr (term (factor 123.456))) - (term (factor 654.321))) \\n) (line (expr (term (term (factor 4.)) * (factor .6))) \\n) (line (expr (expr (term (factor 1))) + (term (term (factor 1)) * (factor 4))) \\n) (line (expr (term (term (factor ( (expr (expr (term (factor 5))) - (term (factor 1))) ))) * (factor 4))) \\n)) 可参考 https://github.com/kobayashi-compiler/kobayashi-compiler 基于 ANTLR 生成的代码编写你的代码（以 Java 为例） 下面我们将以 Java 为例，介绍如何基于 ANTLR 生成的代码实现一个四则运算计算器。 首先定义一个 Visitor 类，继承 calcBaseVisitor，类型参数决定了所有 visitXXX 方法的返回值类型，这里设为 Void。所有的 visitXXX 方法默认调用父类对象的对应方法。 // Visitor.java public class Visitor extends calcBaseVisitor { @Override public Void visitCalculator(calcParser.CalculatorContext ctx) { return super.visitCalculator(ctx); } @Override public Void visitLine(calcParser.LineContext ctx) { return super.visitLine(ctx); } @Override public Void visitExpr(calcParser.ExprContext ctx) { return super.visitExpr(ctx); } @Override public Void visitTerm(calcParser.TermContext ctx) { return super.visitTerm(ctx); } @Override public Void visitFactor(calcParser.FactorContext ctx) { return super.visitFactor(ctx); } } 在每个非终结符对应的方法处，填写我们需要编译器在语法树上遍历到该非终结符对应的节点时执行的动作。 public class Visitor extends calcBaseVisitor { private double nodeValue = 0.0; @Override public Void visitCalculator(calcParser.CalculatorContext ctx) { // 调用默认的 visit 方法即可 return super.visitCalculator(ctx); } @Override public Void visitLine(calcParser.LineContext ctx) { // visit expr 对应的子节点，输出 nodeValue visit(ctx.expr()); System.out.println(\" = \" + nodeValue); return null; } @Override public Void visitExpr(calcParser.ExprContext ctx) { switch (ctx.children.size()) { case 1 -> { // 有 1 个子节点，表示匹配的规则是 expr -> term，直接 visit term 对应的子节点 visit(ctx.term()); } case 3 -> { // 有 3 个子节点，表示匹配的规则是 expr -> expr ADD term | expr SUB term // visit expr 和 term 对应的子节点，获取节点对应的值，根据运算符是 ADD 或 SUB 进行不同运算 double lhs = 0.0, rhs = 0.0, result = 0.0; visit(ctx.expr()); lhs = nodeValue; visit(ctx.term()); rhs = nodeValue; if (ctx.ADD() != null) { result = lhs + rhs; } else { result = lhs - rhs; } nodeValue = result; } } return null; } @Override public Void visitTerm(calcParser.TermContext ctx) { switch (ctx.children.size()) { case 1 -> { // 有 1 个子节点，表示匹配的规则是 term -> factor，直接 visit factor 对应的子节点 visit(ctx.factor()); } case 3 -> { // 有 3 个子节点，表示匹配的规则是 term -> term MUL factor | term DIV factor // visit term 和 factor 对应的子节点，获取节点对应的值，根据运算符是 MUL 或 DIV 进行不同运算 double lhs = 0.0, rhs = 0.0, result = 0.0; visit(ctx.term()); lhs = nodeValue; visit(ctx.factor()); rhs = nodeValue; if (ctx.MUL() != null) { result = lhs * rhs; } else { result = lhs / rhs; } nodeValue = result; } } return null; } @Override public Void visitFactor(calcParser.FactorContext ctx) { switch (ctx.children.size()) { case 1 -> { // 有 1 个子节点，表示匹配的规则是 factor -> NUMBER，将 NUMBER 对应的字符串转换成数字 nodeValue = Double.parseDouble(ctx.NUMBER().getText()); } case 3 -> { // 有 3 个子节点，表示匹配的规则是 factor -> LPAREN expr RPAREN，直接 visit expr 对应的子节点 visit(ctx.expr()); } } return null; } } 修改 Main.java，使用我们编写的 Visitor。 // Main.java import org.antlr.v4.runtime.tree.ParseTree; import org.antlr.v4.runtime.CharStream; import org.antlr.v4.runtime.CharStreams; import org.antlr.v4.runtime.CommonTokenStream; public class Main { public static void main(String[] args) { String input = \"1919 * 810\\n\" + \"123.456 - 654.321\\n\" + \"4. * .6\\n\" + \"1 + 1 * 4\\n\" + \"(5 - 1) * 4\\n\"; CharStream inputStream = CharStreams.fromString(input); calcLexer lexer = new calcLexer(inputStream); CommonTokenStream tokenStream = new CommonTokenStream(lexer); calcParser parser = new calcParser(tokenStream); ParseTree tree = parser.calculator(); Visitor visitor = new Visitor(); visitor.visit(tree); } } 编译运行代码，输出结果如下： 1919*810 = 1554390.0 123.456-654.321 = -530.865 4.*.6 = 2.4 1+1*4 = 5.0 (5-1)*4 = 16.0 在 ANTLR 生成的代码中，每个 Context 都是语法树上的一个节点类。 每个节点的子节点对象可以通过调用节点的对应名称方法来获得，如一个 ExprContext 对象调用 expr() 方法，根据规则 expr: expr ADD term | expr SUB term | term;，当该 ExprContext 对象对应的规则是 expr: expr ADD term | expr SUB term; 时，expr() 返回对应的子节点；当该 ExprContext 对象对应的规则是 expr: term; 时，expr() 返回 null。 每个 Context 都有一个 accept 方法接受 visitor，访问该节点。 calcBaseVisitor 继承的 AbstractParseTreeVisitor 类中，将 accept 方法封装成了一个 visit 方法，接受一个节点作为参数，访问该节点；AbstractParseTreeVisitor 中还实现了一个 visitChildren 方法，遍历一个节点的所有子节点。 你可以在 ANTLR 官网 了解关于 ANTLR 的更多知识 "},"pre/judge.html":{"url":"pre/judge.html","title":"（阅读）评测机食用指北","keywords":"","body":"评测机食用指北 Rurikawa 的文档库（github） "},"pre/lab_lexer.html":{"url":"pre/lab_lexer.html","title":"（实验）词法分析小实验","keywords":"","body":"词法分析小实验 完成本次实验后，你需要提交本次实验的 pdf 格式的实验报告，上传到 pre/词法分析实验/ 中的对应班级目录中，命名规则为 学号_姓名_labLexer.pdf。 评测和提交实验报告的截止时间为 2021 年 10 月 10 日 23:59。 实验内容 在本次实验中，你需要手工编写一个词法分析程序（不允许使用 flex/ANTLR 等自动生成），从输入文件中读入字符串，根据 Token 对照表将识别到的对应 token 输出到标准输出（stdout），每行输出一个 token。 Token 对照表如下： Token 名称 对应字符串 输出格式 备注 标识符 （定义见下） Ident($name) 将 $name 替换成标识符对应的字符串 无符号整数 （定义见下） Number($number) 将 $number 替换成标识符对应的字符串 if if If else else Else while while While break break Break continue continue Continue return return Return 赋值符号 = Assign 分号 ; Semicolon 左括号 ( LPar 右括号 ) RPar 左大括号 { LBrace 右大括号 } RBrace 加号 + Plus 乘号 * Mult 除号 / Div 小于号 Lt 大于号 > Gt 等于号 == Eq 错误 不能符合上述 token 规则的字符串 Err 程序应输出 Err 后终止 标识符和无符号整数的文法定义如下： Letter -> 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' Digit -> '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' Underline -> '_' Nondigit -> Letter | Underline -> Nondigit | Nondigit | Digit -> Digit | Digit 注意事项： 程序的关键字应区分大小写，程序中所有完全匹配上关键字的字符串不应被识别为标识符； 保证无符号整数的范围为 0 ，不会出现范围之外的数字； 空格、制表符、换行符有分割 token 的作用。在现代编译器中，通常不会直接暴力地去除输入中的空白字符。gcc 和 clang 遇到 a = 1 0; 时，都会报语法错误，而不是按 a=10; 处理，说明词法分析时保留了空白符，到语法分析时发现存在错误。对于我们的词法分析程序，不需要将空白符作为一个 token，但需要其发挥分割的作用，遇到 a = 1 0; 时应当分别识别出 Number(1) 和 Number(0)； 在遇到文法中存在二义性的情况时（如 === 可以被识别成 Assign\\nEq、Eq\\nAssign 或 Assign\\nAssign\\nAssign），默认遵循最长匹配原则，即要尽可能多地识别一个 token 可以接受的字符。对于 ===，应识别成 Eq\\nAssign。 示例 输入样例 1： a = 10; c = a * 2 + 3; return c; 输出样例 1： Ident(a) Assign Number(10) Semicolon Ident(c) Assign Ident(a) Mult Number(2) Plus Number(3) Semicolon Return Ident(c) Semicolon 输入样例 2： a = 10; :c = a * 2 + 3; return c; 输出样例 2： Ident(a) Assign Number(10) Semicolon Err 输入样例 3： a = 3; If = 0 while (a 输出样例 3： Ident(a) Assign Number(3) Semicolon Ident(If) Assign Number(0) While LPar Ident(a) Lt Number(4396) RPar LBrace If LPar Ident(a) Eq Number(010) RPar LBrace Ident(ybb) Assign Number(233) Semicolon Ident(a) Assign Ident(a) Plus Ident(ybb) Semicolon Continue Semicolon RBrace Else LBrace Ident(a) Assign Ident(a) Plus Number(7) Semicolon RBrace Ident(If) Assign Ident(If) Plus Ident(a) Mult Number(2) Semicolon RBrace 评测 评测在 10 月 1 日开放，10 月 10 日 23:59 截止评测。你的词法分析器可以通过命令行参数指定文件路径或从标准输入读入输入文件，你需要输出结果到标准输出中。 Dockerfile 和 judge.toml 的编写格式见 提交作业的格式与方法。 一个配置文件的示例如下： # -- Dockerfile -- # 这个文件负责构建包含你的程序的 Docker 容器 # 使用 Java 12 FROM openjdk:12-alpine # 向容器内复制文件 COPY ./* /app/ # 编译程序 WORKDIR /app/ RUN javac -d ./output ./my/path/MyClass.java # 将当前目录设为 /app/output WORKDIR /app/output # -- judge.toml -- # 这个文件负责告诉评测姬你需要怎么评测你的程序 # 我们的评测标识符是 lexer [jobs.lexer] # 使用 Dockerfile 来源，路径就是当前文件夹 image = { source = \"dockerfile\", path = \".\" } # 假如你用的是 Java run = [ # 运行程序 \"java my.path.MyClass $input\", ] 评测机提供的输入是一个文件路径 $input，你的词法分析器可以选择将文件作为命令行参数传入后读取文件，也可以选择使用 cat $input | 从标准输入读入。 "},"miniSysY.html":{"url":"miniSysY.html","title":"剩下的旅程：miniSysY","keywords":"","body":"剩下的旅程：miniSysY miniSysY 语言是在 SysY 语言 基础上进行一些修改得到的 C 语言子集。编译原理实验课剩下的工作就是从编译一个简单的 main() 函数开始，逐渐扩充对 miniSysY 语言文法的支持，实现一个较为完整的编译器。由于我们没有系统地学习过汇编语言，我们只需要将 miniSysY 代码编译到 LLVM IR。 在后续的实验中，你可以使用自动生成工具（如 ANTLR、flex/bison 等）来生成你的编译器前端代码，也可以选择手工实现前端的词法分析和语法分析代码。 关于评测：你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 实验概览 miniSysY 实验共有 8 个 lab 和一个挑战实验。 8 个 lab 会以每周一个的速度放出，所有实验的评测和提交实验报告截止时间为第 17 周周末（2022 年 1 月 2 日）。期末会放出示例编译器。部分 lab 包括多个 part，只是为了方便你迭代实现和调试，在评测时你可以选择一部分已经实现的 part 进行评测，以降低等待时间。需要注意的是，你需要在一次评测中通过所有 part 的测试点才算完成一个 lab。 挑战实验选做其中一部分即可，得分不会溢出。为了便于你设计架构，挑战实验会提前放出内容。 仅有 main 函数的编译器及注释（10%） 常量表达式运算（10%） 局部变量定义与赋值（10%） if 语句与条件表达式（10%） 作用域与全局变量（10%） 循环（10%） 数组（10%） 函数（10%） 挑战实验（20%） mem2reg（20%） 多维数组（10%） 函数内联（10%） 短路求值（10%） miniSysY 文法 为了便于你设计架构，现给出 miniSysY 的全部文法如下： CompUnit -> [CompUnit] (Decl | FuncDef) Decl -> ConstDecl | VarDecl ConstDecl -> 'const' BType ConstDef { ',' ConstDef } ';' BType -> 'int' ConstDef -> Ident { '[' ConstExp ']' } '=' ConstInitVal ConstInitVal -> ConstExp | '{' [ ConstInitVal { ',' ConstInitVal } ] '}' VarDecl -> BType VarDef { ',' VarDef } ';' VarDef -> Ident { '[' ConstExp ']' } | Ident { '[' ConstExp ']' } '=' InitVal InitVal -> Exp | '{' [ InitVal { ',' InitVal } ] '}' FuncDef -> FuncType Ident '(' [FuncFParams] ')' Block FuncType -> 'void' | 'int' FuncFParams -> FuncFParam { ',' FuncFParam } FuncFParam -> BType Ident ['[' ']' { '[' Exp ']' }] Block -> '{' { BlockItem } '}' BlockItem -> Decl | Stmt Stmt -> LVal '=' Exp ';' | [Exp] ';' | Block | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] | 'while' '(' Cond ')' Stmt | 'break' ';' | 'continue' ';' | 'return' [Exp] ';' Exp -> AddExp Cond -> LOrExp LVal -> Ident {'[' Exp ']'} PrimaryExp -> '(' Exp ')' | LVal | Number UnaryExp -> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp UnaryOp -> '+' | '-' | '!' // 注：保证 '!' 仅出现在 Cond 中 FuncRParams -> Exp { ',' Exp } MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp AddExp -> MulExp | AddExp ('+' | '−') MulExp RelExp -> AddExp | RelExp ('' | '=') AddExp EqExp -> RelExp | EqExp ('==' | '!=') RelExp LAndExp -> EqExp | LAndExp '&&' EqExp LOrExp -> LAndExp | LOrExp '||' LAndExp ConstExp -> AddExp // 在语义上额外约束这里的 AddExp 必须是一个可以在编译期求出值的常量 其中 Ident 和 Number 的详细定义见下。 文法的细节补充 注释 miniSysY 语言中有两种注释，包括以 // 开头的单行注释和包裹在 /*、*/ 中的多行注释。 单行注释：以 // 开始，直到换行符结束，不包括换行符。 多行注释：以 /* 开始，直到第一次出现 */ 时结束，包括 */。 标识符 Ident 的定义 Ident -> Nondigit | Ident Nondigit | Ident Digit Nondigit -> '_' | 'a' | 'b' | ... | 'z' | 'A' | 'B' | ... | 'Z' Digit -> '0' | '1' | ... | '9' 对于同名标识符的规定： 全局变量和局部变量的作用域可以重叠，重叠部分局部变量优先； 同名局部变量的作用域不能重叠； 变量名可以与函数名相同。 数字 Number 的定义 Number 可以表示八进制、十进制、十六进制数字，文法如下： Number -> decimal-const | octal-const | hexadecimal-const decimal-const -> nonzero-digit | decimal-const digit octal-const -> '0' | octal-const octal-digit hexadecimal-const -> hexadecimal-prefix hexadecimal-digit | hexadecimal-const hexadecimal-digit hexadecimal-prefix -> '0x' | '0X' nonzero-digit -> '1' | '2' | ... | '9' octal-digit -> '0' | '1' | ... | '7' digit -> '0' | nonzero-digit hexadecimal-digit -> '0' | '1' | ... | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' 在将 Number 翻译成 LLVM IR 中的常量数字时，你需要注意进制的转换。输入保证 Number 转换成十进制后范围为 0 ，不会出现范围之外的数字。 语义约束 CompUnit 一个 miniSysY 程序由单个文件组成，对应 EBNF 表示中的一个 CompUnit。在该 CompUnit 中，必须存在且仅存在一个标识为 main 、无参数、返回类型为 int 的 FuncDef。 CompUnit 的顶层变量/常量声明语句（对应 Decl）、函数定义（对应 FuncDef）都不可以重复定义同名标识符（Ident），即便标识符的类型不同也不允许。 CompUnit 的变量/常量/函数声明的作用域从该声明处开始到文件结尾。 ConstInitVal 和 InitVal 全局变量声明中指定的初值表达式必须是常量表达式。 常量或变量声明中指定的初值要与该常量或变量的类型一致。 未显式初始化的局部变量，其值是不确定的；而未显式初始化的全局变量，其值均被初始化为 0。 ConstDef ConstDef 用于定义常量。在 Ident 后、= 之前是可选的数组维度和各维长度的定义部分，在 = 之后是初始值。 ConstDef 的数组维度和各维长度的定义部分不存在时，表示定义单个变量。此时 = 右边必须是单个初始数值。 ConstDef 的数组维度和各维长度的定义部分存在时，表示定义数组。其语义和 C 语言一致，miniSysY 基础实验只要求支持一维数组和二维数组。比如[2*3][8/2]表示二维数组，第一和第二维长度分别为 6 和 4，每维的下界从 0 编号。 ConstDef 中表示各维长度的 ConstExp 都必须能在编译时求值到非负整数。在声明数组时各维长度都需要显式给出，而不允许是未知的。 当 ConstDef 定义的是数组时，= 右边的 ConstInitVal 表示常量初始化器。全局常量数组的 ConstInitVal 中的 ConstExp 必须是常量表达式。局部常量数组的 ConstInitVal 中的 ConstExp 必须是能在编译时求值的 int 型表达式。 ConstInitVal 初始化器必须是以下三种情况之一： 一对花括号 {}，表示所有元素初始为 0； 数组维数和各维长度完全对应的初始值，如 int a[3] = {1, 2, 3};、int a[3][2] = { {1, 2}, {3, 4}, {5, 6} };； 花括号中初始值少于对应维度元素个数，该维其余部分将被隐式初始化为 0，如 int a[5] = {1, 2};、int a[4][3] = { {1, 2, 3}, {4, 5}, {} };。 VarDef VarDef 用于定义变量。当不含有 = 和初始值时，其运行时实际初值未定义。 VarDef 的数组维度和各维长度的定义部分不存在时，表示定义单个变量。存在时，和 ConstDef 类似，表示定义数组。 VarDef 中表示各维长度的 ConstExp 必须能求值到非负整数。 全局变量数组的 InitVal 中的 Exp 必须是常量表达式。局部变量数组 InitVal 中的 Exp 可以是任何符合语义的表达式。 FuncFParam 与实参 FuncFParam 定义一个函数的一个形式参数。当 Ident 后面的可选部分存在时，表示该形式参数为一个数组。 当 FuncFParam 为数组定义时，其第一维的长度省去（用方括号 [] 表示），而第二维则需要用表达式指明长度，长度是编译时可求值的常量表达式。 函数实参的语法是 Exp。对于 int 类型的参数，遵循按值传递；对于数组类型的参数，则形参接收的是实参数组的地址，并通过地址间接访问实参数组中的元素。 可以将二维数组的一部分传到形参数组中，如定义了 int a[4][3]，可以将 a[1] 作为一个包含三个元素的一维数组传递给类型为 int[] 的形参。 FuncDef FuncDef 表示函数定义。其中的 FuncType 指明返回类型。 当返回类型为 int 时，函数内所有分支都应当含有带有 Exp 的 return 语句。不含有 return 语句的分支的返回值未定义； 当返回值类型为 void 时，函数内只能出现不带返回值的 return 语句。 Block Block 表示语句块。语句块会创建作用域，语句块内声明的变量的生命周期在该语句块内。 语句块内可以再次定义与语句块外同名的变量或常量（通过 Decl 语句)，其作用域从定义处开始到该语句块尾结束，它隐藏语句块外的同名变量或常量。 Stmt Stmt 中的 if 类型语句遵循就近匹配。 单个 Exp 可以作为 Stmt。Exp 会被求值，所求的值会被丢弃。 LVal LVal 表示具有左值的表达式，可以为变量或者某个数组元素。 当 LVal 表示数组时，方括号个数必须和数组变量的维数相同。 Exp 和 Cond Exp 代表 int 类型的表达式，Cond 代表条件表达式。单目运算符 ! 只会在 Cond 中出现。 LVal 必须是当前作用域内、该 Exp 语句之前有定义的变量或常量；对于赋值号左边的 LVal 必须是变量。 miniSysY 算符的优先级与结合性与 C 语言一致，文法中已经体现出了优先级与结合性的定义。 Cond 中的短路求值在基础实验中不作要求，挑战实验中会有相关内容。 运行时库 在 lab3 及之后的 lab 中，评测样例会调用 miniSysY 运行时库的函数来完成输入输出。运行时库提供一系列 I/O 函数，用于在程序中表达输入/输出需求，这些库函数不用在程序中声明即可调用，因此在 lab3 之后，你的编译器需要支持在调用这些库函数时直接翻译成对应的 LLVM IR 形式的调用，但不需要检查这些库函数参数的合法性。评测时评测机会将运行时库链接并进行评测，在本地调试时怎样链接运行时库会在后续实验中说明。 运行时库的函数 int getint();：输入一个整数，返回对应的整数值。int n; n = getint(); int getch();：输入一个字符，返回字符对应的 ASCII 码值。int n; n = getch(); int getarray(int []);：输入一串整数，第 1 个整数代表后续要输入的整数个数，该个数通过返回值返回；后续的整数通过传入的数组参数返回。getarray() 不会检查调用者提供的数组是否有足够的空间容纳输入的一串整数。int a[10][10]; int n; n = getarray(a[0]); void putint(int);：输出一个整数的值。int n = 10; putint(n); putint(11); void putch(int);：输出一个 ASCII 码对应的字符。传入的整数参数取值范围为 0~255。int n = 10; putch(n); void putarray(int, int[]); 第 1 个参数表示要输出的整数个数（假设为 N），后面应该跟上要输出的 N 个整数的数组。putarray() 在输出时会在整数之间安插空格。int n = 2; int a[2] = {2, 3}; putarray(n, a); "},"lab1/compiler_structure.html":{"url":"lab1/compiler_structure.html","title":"编译过程概述","keywords":"","body":"编译过程概述 在我们刚开始学编程的时候，代码的执行对我们来说就像是魔法一样：我们输入一些字符串，并且把它们交给编译器就行了。对于当时的我们来说，编译仅仅意味着“IDE 上的运行按钮”（或者是命令行里面的一串神秘指令）。我们要做的就是写好代码，点击这个按钮，这些字符串就神奇地运行起来（或者是神奇地报错）了。 在我们接触了汇编语言以后，我们知道了输入的字符串会被编译为汇编语言（对于编译型语言来说），这些汇编语言导出的二进制能够直接在 CPU 上跑起来并实现我们的目标，并且我们也能够自己手工编写一些简单的汇编程序（比如写一个排序函数或者是与系统调用配合让屏幕上闪烁炫酷的 RGB 字符）。 上方的拼图和下方的拼图都找到了，但现在我们眼前还有一个问题：我们输入的源语言是怎么变成汇编语言的呢？ 我们都知道答案是编译器，但编译器具体是怎么做的，世界上第一个编译器是怎么写的，现在我们还不清楚。所幸，我们将在接下来的旅程中弄明白这个问题。1 1. 剧透：是蛋先生的鸡，世界上第一个编译器是用汇编语言写的。 ↩ 这一节的主要任务是针对编译的过程进行一个总体性质的介绍，目的是让同学们对编译的理解不再流于书本上的描述，并对编译过程形成一个大致的，能够将想法映射到代码上的印象：编译器有哪些部分，他们有什么功能，各个部分之间是如何合作的，该怎么实现。而具体的实现指导与技术点，我们将在各个 lab 中进行详细的介绍。如果将来报道出现了偏差，以每个 lab 中具体的要求为准。计算机最重要的思想之一就是分层抽象，在任意两层之间，还可以按照设计者的意愿再次添加抽象层。而软件架构的设计和实现，是为了解决现实世界的具体问题，会面临资源、财力、物力、人力、时间等多种因素的掣肘，就会诞生一些“不那么规矩”、“不那么单纯”的架构或组件/软件，它们往往会跨层次，跨模块，大模块拆小，小模块合并，甚至打破一些“金科玉律”等。相比于弄懂一个名词，更多的精力应该放在理解事物的本质上，只要把解决问题的流程和方法弄明白了，解决问题的过程中所用到的子流程、工具、方法，你爱怎么叫怎么叫，甚至自己发明名词也可以（只是与外人沟通可能会不太顺畅）。 所以，当你看到示例编译器和这里的介绍的做法有不同甚至是完全不一样的时候，这一般来说并不是示例编译器或者教程“错了”，而更可能是我们给问题找到了另一种解法。2 2: 引自 https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/71 一个常见的编译器大致分为三个部分：前端，中端与后端（在很多书上也会将中端归为后端的一部分），他们分别承担了以下的任务 编译器前端会将源程序读入，在进行词法分析和语法分析以后将源程序转化为一棵抽象语法树 (Abstract Syntax Tree, AST)，并在此基础上对语法树进行扫描，对其进行语义分析，检查是否有语义错误。 编译器的中端会对 AST 进行扫描，并生成对应的一层或者是多层的中间表达形式（Intermediate Representation, IR），并对其进行优化（LLVM IR 就是一个拥有较活跃生态的中间表达形式）。 编译器的后端通常会将 IR 转化为具体体系结构的汇编代码 (MIPS, x86, arm, RISC-V, ...)，并在这个基础上做一些面向体系结构的优化。 那我们的实验最后实现的编译器和常见的编译器有什么区别呢？ 实际上现在大多数编译器的实现方式都是手写递归下降（比如 GCC 曾经使用的就是 YACC（BISON）的解决方案，但他们在 3.x 的时候放弃了这个方案），使用 ANTLR/FLEX/BISON/其他辅助分析工具的编译器比较少，因为对于不断变动和改进的语言来说，递归下降解析器是便于理解，编写和调试的。 但是，我们的部分示例编译器仍然使用了分析工具。对于不会变动的语言，使用辅助工具不失是一个比较好的选择。而且不是每位同学以后都会从事编译相关的工作，能够手写递归下降解析固然很酷炫，但掌握这些工具却确实可能会在某些情况下帮上大忙（如解析一些配置文件、实现数据库前端、实现浏览器等）。 我们的编译器对错误处理的要求是比较低的，当检测到错误时只需要以一个非 0 值退出就行。但这并不代表错误处理是不重要的，实际上，一个错误处理做得好的编译器能给程序员的编程体验带来很大的提升。 我们在中端部分几乎只进行生成 LLVM IR 这一步，一些简单的优化将会作为挑战实验发布。 我们的编译器没有传统意义上的后端，我们的实验将止步于输出 LLVM IR，这意味着你不用分配内存和寄存器等。 词法分析和语法分析 词法分析的作用是从左到右扫描源程序，识别出程序源代码中的标识符、保留字、整数常量、算符、分界符等单词符号（即终结符），并把识别结果返回给语法分析器，以供语法分析器使用。 语法分析是在词法分析的基础上针对所输入的终结符串建立语法树，并对不符合语法规则的程序进行报错处理。 比如对于下面的这段 MiniSysY 的代码： int main() { return 0; } 它在经过词法分析后变成了一个 Token 序列，而语法分析根据这个 Token 序列携带的信息产生了一棵抽象语法树。 它完整的语法分析树长这个样子： 双引号下的和大写的都为词法分析器产出的终结符。 词法分析和语法分析的最终结果是产生了一棵跟我们输入的 MiniSysY 程序所对应的语法树。 这个阶段实验的重点与难点根据你选择的实现方式而不同，如果你选择的是 ANTLR 或者 FLEX/BISON，那么对你来说重难点在于学习这些工具的使用方法，并在这个基础上结合你在课程中学到的知识对文法进行处理从而使其符合工具的要求；如果你选择的是手工实现递归下降，那么对你来说重难点在于自己实现语法分析的这整个过程。 语义分析 如果语法分析的过程成功结束了，并且输出了一棵正常的 AST, 那么说明输入的 MiniSysY 源程序是符合文法的，但一个符合文法的源程序并不一定是一个正确的源程序，比如 int main() { return a; //a 并没有被声明和初始化 } 而这种错误是我们无法在词法分析和语法分析中发现的，所以，编译器还需要对语法分析得到的语句进行分析，从而了解每个程序语句具体的含义，这个过程称为语义分析，如果一个程序成功地通过了语义分析，那说明这个程序的含义对于编译器来说是明确的，编译器的翻译工作能够继续进行下去。值得注意的是，通过了语义分析的代码也不一定是完全正确的，以 C 语言为例，我们有很多时候会对内存直接进行操作（比如你的代码直接修改某个地址上的值并对其进行转型复制#%&*等魔法操作），而这些操作的正确性是不能被编译器保证的（一般称为未定义行为，UB）。 语义分析通常分为两个部分：分析符号含义和检查语义正确性，在实践中，语义分析还通常会和中间代码生成同时进行。 分析符号含义指的是对于表达式中出现的符号，找出这个符号代表的内容，这个工作主要通过符号表来实现。检查语义正确性指的是检查每条语句是否合法，比如检查每个表达式的操作数是否符合要求，每个表达式是否为语言规范中所规定的合法的表达式，使用的变量是否都经过定义等。 总的来说，在这一阶段，我们会对 AST 进行扫描（扫描几遍取决于你的实现方式），并且完成以下的检查 符号表构建：声明了哪些标识符，待编译程序使用的标识符对应于哪个位置的声明。 类型检查：各语句和表达式是否类型正确 如果编译器在这个阶段发现了错误，那么通常整个编译过程在这一阶段结束以后就将终止，并且报告编译错误。 构建符号表 符号表是编译器编译过程中的一种特殊数据结构，通常用来记录变量和函数的声明以及其他信息。在分析表达式和语句的时候，如果这些表达式或者语句引用了某些标识符，我们可以在符号表中查询这些标识符是否有对应的定义或者说信息。符号表的层次结构和作用域是一一对应的，这样做有利于查出符号是否有重定义，以及确定不同作用域引用的标识符。 类型检查 完成符号表建构后，我们就可以自顶向下地遍历AST,对对应的节点进行类型检查。对于静态类（statically-typed）语言，在语言设计之初，设计者都会考虑该语言支持表达哪些类型，并给出定型规则（typing rules）。在已知定型规则的情况下编码实现类型检查算法并不困难——往往只要逐条将其翻译为代码即可。 事实上，MiniSysY语言只有int和void俩类型。类型检查的大概只有在区分int和int[]的时候会被用到。 三地址码与LLVM IR 在此不再赘述，LLVM IR是一种特殊的三地址码，详见LLVM IR 快速上手 "},"lab1/lab1.html":{"url":"lab1/lab1.html","title":"lab 1：main 与注释","keywords":"","body":"Lab 1: main 与注释 本次实验包括两个部分，你需要完成一个简单的编译器，支持以下两个功能（这两个部分会在一起评测）： 能够处理只包含一条 return 语句的 main 函数 能够消除程序中的注释 实验评测截止时间：2022 年 1 月 2 日 23:59 实验报告命名格式：学号_姓名_lab1.pdf 实验报告提交：北航云盘 lab1：main 与注释/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"lab1/part1_task.html":{"url":"lab1/part1_task.html","title":"part1：仅有 main 函数与 return 的编译器","keywords":"","body":"Part 1 仅有 main 函数与 return 的编译器 任务 在 Part 1 中，你需要完成一个可以将一个 main 函数（仅有一条 return 语句）编译成 LLVM IR 的编译器。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> FuncDef FuncDef -> FuncType Ident '(' ')' Block FuncType -> 'int' Ident -> 'main' Block -> '{' Stmt '}' Stmt -> 'return' Number ';' 其中 Number 可以表示八进制、十进制、十六进制数字，文法如下： Number -> decimal-const | octal-const | hexadecimal-const decimal-const -> nonzero-digit | decimal-const digit octal-const -> '0' | octal-const octal-digit hexadecimal-const -> hexadecimal-prefix hexadecimal-digit | hexadecimal-const hexadecimal-digit hexadecimal-prefix -> '0x' | '0X' nonzero-digit -> '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' octal-digit -> '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' digit -> '0' | nonzero-digit hexadecimal-digit -> '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' 在将 Number 翻译成 LLVM IR 中的常量数字时，你需要注意进制的转换。输入保证 Number 转换成十进制后范围为 0 ，不会出现范围之外的数字。 示例 输入样例 1： int main() { return 123; } 输出样例 1： define dso_local i32 @main(){ ret i32 123 } 输入样例 2： int main() { return 0 } 输出样例 2： 如果编译过程中出现了错误（语法、语义等错误），你的编译器应当直接以非 0 的返回值退出。 "},"lab1/part2_task.html":{"url":"lab1/part2_task.html","title":"part2：消除注释","keywords":"","body":"Part 2 消除注释 任务 miniSysY 语言中有两种注释，包括以 // 开头的单行注释和包裹在 /*、*/ 中的多行注释。 单行注释：以 // 开始，直到换行符结束，不包括换行符。 多行注释：以 /* 开始，直到第一次出现 */ 时结束，包括 */。 在 Part 2 中，你需要识别出程序中包含的注释，并在编译过程中跳过这些注释。 思考题 你的编译器是怎样消除代码中的注释的？请简要说明。 示例 输入样例 1： int main() { // mian return /* 123 */ 234; } 输出样例 1： define dso_local i32 @main(){ ret i32 234 } 输入样例 2： int main() { /* return 123; } 输出样例 2： 编译器直接以非 0 的返回值退出。 "},"lab1/help.html":{"url":"lab1/help.html","title":"实验指导","keywords":"","body":"Lab 1 实验指导 Lab1 是你实现 miniSysY 编译器的第一个实验，尽管本次实验的内容很少——只需要支持一个 main 函数即可，但后续的实验会在上一次实验的基础上迭代，好的架构可以有效降低后续迭代的复杂程度。你应该按照编写一个编译器的流程，设计好词法分析、语法分析、语义分析、生成 LLVM IR 等步骤的架构，保证它们有一定的可扩展性，以方便后续实验的进行。 在还没有引入 miniSysY 标准库中的 putint() 之前，评测机都会通过返回值来判断你生成的代码执行得是否正确。你的编译器输出的 LLVM IR 在本地编译或解释执行后看起来并没有任何效果，它只是返回了一个数字，不会在标准输出中输出任何东西。在 Unix & Linux 中，你可以通过 echo $? 来查看最后运行的命令的返回值。需要注意的是，echo $? 输出的是返回值对 256 取模后的结果。 "},"lab1/judge.html":{"url":"lab1/judge.html","title":"评测说明","keywords":"","body":"评测说明 本次实验的评测标识符为 lab1，即你的 judge.toml 第一行应改为 [jobs.lab1]。 你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 # 一个示例 [jobs.lab1] image = { source = \"dockerfile\", path = \".\" } run = [ \"./compiler $input $ir\", ] 如果编译过程中出现了错误（语法、语义、编译过程错误等），你的编译器应当以非 0 的返回值退出（或抛出异常）。否则如果一切正常，你的编译器应当正常退出。 "},"lab2/lab2.html":{"url":"lab2/lab2.html","title":"lab 2：常量表达式","keywords":"","body":"Lab 2：常量表达式 本次实验包括两个部分，你的编译器需要在 lab 1 的基础上支持以下两个功能（这两个部分会在一起评测）： 实现正号、负号 实现四则运算及模运算 实验评测截止时间：2022 年 1 月 2 日 23:59 实验报告命名格式：学号_姓名_lab2.pdf 实验报告提交：北航云盘 lab2：常量表达式/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"lab2/part3_task.html":{"url":"lab2/part3_task.html","title":"part3：实现正号、负号","keywords":"","body":"Part 3 实现正号、负号 在 Part 3 中，你的编译器需要支持正号、负号以及表达式中可能存在的括号。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> FuncDef FuncDef -> FuncType Ident '(' ')' Block FuncType -> 'int' Ident -> 'main' Block -> '{' Stmt '}' Stmt -> 'return' Exp ';' Exp -> AddExp AddExp -> MulExp MulExp -> UnaryExp UnaryExp -> PrimaryExp | UnaryOp UnaryExp PrimaryExp -> '(' Exp ')' | Number UnaryOp -> '+' | '-' 示例 样例程序 1： int main() { return ---(-1); } 示例 IR 1： define dso_local i32 @main() { %1 = sub i32 0, 1 %2 = sub i32 0, %1 %3 = sub i32 0, %2 %4 = sub i32 0, %3 ret i32 %4 } 示例返回值 1（lli 解释执行后）： 1 样例程序 2： int main() { return +-+-010; } 示例 IR 2： define dso_local i32 @main() { %1 = sub i32 0, 8 %2 = sub i32 0, %1 ret i32 %2 } 示例返回值 2（lli 解释执行后）: 8 样例程序 3： int main() { return -+(+-((-+(-+(1)))); } 示例 IR 3： 编译器直接以非 0 的返回值退出。 "},"lab2/part4_task.html":{"url":"lab2/part4_task.html","title":"part4：实现四则运算及模运算","keywords":"","body":"Part 4 实现四则运算及模运算 在 Part 4 中，你的编译器需要实现四则运算以及模运算。 miniSysY 算符的优先级与结合性与 C 语言一致，文法中已经体现出了优先级定义，同一优先级的运算符运算顺序为从左到右运算。 如果你打算手工实现编译器，并且采用了递归下降的语法分析方式，在分析四则运算相关的语法时局部采用算符优先分析法可能效果会更好。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> FuncDef FuncDef -> FuncType Ident '(' ')' Block FuncType -> 'int' Ident -> 'main' Block -> '{' Stmt '}' Stmt -> 'return' Exp ';' Exp -> AddExp AddExp -> MulExp | AddExp ('+' | '−') MulExp MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp UnaryExp -> PrimaryExp | UnaryOp UnaryExp PrimaryExp -> '(' Exp ')' | Number UnaryOp -> '+' | '-' 其中除法取整和模运算规则与 C 语言 int 类型相同。 示例 样例程序 1： int main() { return 1 + (-2) * (3 / (4 - 5)); } 示例 IR 1： define dso_local i32 @main() { %1 = sub i32 0, 2 %2 = sub i32 4, 5 %3 = sdiv i32 3, %2 %4 = mul i32 %1, %3 %5 = add i32 1, %4 ret i32 %5 } 示例返回值 1（lli 解释执行后）： 7 输入样例 2： int main() { return 1 +-+ (- - - - - - - - -1); } 示例 IR 2： define dso_local i32 @main() { %1 = sub i32 0, 1 %2 = sub i32 0, %1 %3 = sub i32 0, %2 %4 = sub i32 0, %3 %5 = sub i32 0, %4 %6 = sub i32 0, %5 %7 = sub i32 0, %6 %8 = sub i32 0, %7 %9 = sub i32 0, %8 %10 = sub i32 0, %9 %11 = add i32 1, %10 ret i32 %11 } 示例返回值 2（lli 解释执行后）： 2 输入样例 3： int main() { return 4 * (1 / 5) - 4 + 1 ** 1; } 示例 IR 3： 编译器直接以非 0 的返回值退出。 "},"lab2/help.html":{"url":"lab2/help.html","title":"实验指导","keywords":"","body":"Lab 2 实验指导 在你使用 clang 测试生成样例中的部分代码时，需要注意 C 语言中存在 ++ 和 -- 运算符，连写的 + 和 - 会首先被词法分析识别成 ++ 和 -- 运算符，导致编译失败，你需要在连写的 + 和 - 之间加上空格。miniSysY 的文法中不会出现 ++ 和 -- 运算符，你在词法分析时不需要为此预留额外的兼容代码。 下面是一个例子： int main() { return 1 +-+ (- - -15) / 0x5; } define dso_local i32 @main(){ %x0 = sub i32 0, 15 %x1 = sub i32 0, %x0 %x2 = sub i32 0, %x1 %x3 = sub i32 0, %x2 %x4 = sdiv i32 %x3, 5 %x5 = add i32 1, %x4 ret i32 %x5 } 关于 LLVM IR 的进一步介绍：LLVM 中的 SSA、LLVM IR 中最重要的概念，以及编译器设计的提示。 "},"lab2/judge.html":{"url":"lab2/judge.html","title":"评测说明","keywords":"","body":"评测说明 本次实验的评测标识符为 lab2，即你的 judge.toml 第一行应改为 [jobs.lab2]。 你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 # 一个示例 [jobs.lab2] image = { source = \"dockerfile\", path = \".\" } run = [ \"./compiler $input $ir\", ] 如果编译过程中出现了错误（语法、语义、编译过程错误等），你的编译器应当以非 0 的返回值退出（或抛出异常）。否则如果一切正常，你的编译器应当正常退出。 "},"lab3/lab3.html":{"url":"lab3/lab3.html","title":"lab 3：局部变量","keywords":"","body":"Lab 3：局部变量 本次实验包括两个部分，你的编译器需要在 lab 2 的基础上支持以下两个功能（这两个部分会在一起评测）： 实现局部变量、局部常量的声明和使用 实现对 miniSysY 库函数的调用 注意：本次实验的 Part 5 和 Part 6 都使用 miniSysY 库函数进行输入输出，Part 5 中只会使用到 putint()，建议在 Part 5 和 Part 6 都完成后再进行提交。 实验评测截止时间：2022 年 1 月 2 日 23:59 实验报告命名格式：学号_姓名_lab3.pdf 实验报告提交：北航云盘 lab3：局部变量/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"lab3/part5_task.html":{"url":"lab3/part5_task.html","title":"part5：局部变量与赋值","keywords":"","body":"Part 5 局部变量与赋值 终于可以支持一个像样的程序了 在 Part 5 中，你的编译器需要增加对局部变量的支持（当然也包括局部常量）。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> FuncDef Decl -> ConstDecl | VarDecl ConstDecl -> 'const' BType ConstDef { ',' ConstDef } ';' BType -> 'int' ConstDef -> Ident '=' ConstInitVal ConstInitVal -> ConstExp ConstExp -> AddExp VarDecl -> BType VarDef { ',' VarDef } ';' VarDef -> Ident | Ident '=' InitVal InitVal -> Exp FuncDef -> FuncType Ident '(' ')' Block // 保证当前 Ident 只为 \"main\" FuncType -> 'int' Block -> '{' { BlockItem } '}' BlockItem -> Decl | Stmt Stmt -> LVal '=' Exp ';' | [Exp] ';' | 'return' Exp ';' LVal -> Ident Exp -> AddExp AddExp -> MulExp | AddExp ('+' | '−') MulExp MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp UnaryExp -> PrimaryExp | UnaryOp UnaryExp PrimaryExp -> '(' Exp ')' | LVal | Number UnaryOp -> '+' | '-' 标识符 Ident 的定义 Ident -> Nondigit | Ident Nondigit | Ident Digit Nondigit -> '_' | 'a' | 'b' | ... | 'z' | 'A' | 'B' | ... | 'Z' Digit -> '0' | '1' | ... | '9' 对于同名标识符的规定： 全局变量和局部变量的作用域可以重叠，重叠部分局部变量优先； 同名局部变量的作用域不能重叠； 变量名可以与函数名相同。 语义约束 ConstInitVal ConstInitVal 中的 ConstExp 必须是能在编译时求值的 int 型表达式，其中可以引用已定义的常量。 VarDef VarDef 用于定义变量。当不含有 = 和初始值时，其运行时实际初值未定义。 当 VarDef 含有 = 和初始值时， = 右边的 InitVal 和 ConstInitVal 的结构要求相同，唯一的不同是 ConstInitVal 中的表达式是 ConstExp 常量表达式，而 InitVal 中的表达式可以是当前上下文合法的任何 Exp。 Block Block 内不能有同名的变量或常量。 Stmt 单个 Exp 可以作为 Stmt。该 Exp 会被求值，所求的值会被丢弃。 LVal 赋值号左边的 LVal 必须是变量；Exp 中的 LVal 必须是当前作用域内、该 Exp 语句之前有定义的变量或常量。 示例 样例 1 样例程序 1： int main() { int a = 123 - 122; return a; } 示例 IR 1： define dso_local i32 @main(){ %1 = alloca i32 %2 = sub i32 123, 122 store i32 %2, i32* %1 %3 = load i32, i32* %1 ret i32 %3 } 输出样例 1： 1 样例 2 样例程序 2： int main() { const int Nqn7m1 = 010; int yiersan = 456; int mAgIc_NuMbEr; mAgIc_NuMbEr = 8456; int a1a11a11 = (mAgIc_NuMbEr - yiersan) / 1000 - Nqn7m1, _CHAOS_TOKEN; _CHAOS_TOKEN = 2; a1a11a11 = a1a11a11 + _CHAOS_TOKEN; return a1a11a11 - _CHAOS_TOKEN + 000; } 示例 IR 2： define dso_local i32 @main(){ %1 = alloca i32 %2 = alloca i32 %3 = alloca i32 %4 = alloca i32 store i32 456, i32* %4 store i32 8456, i32* %3 %5 = load i32, i32* %3 %6 = load i32, i32* %4 %7 = sub i32 %5, %6 %8 = sdiv i32 %7, 1000 %9 = sub i32 %8, 8 store i32 %9, i32* %2 store i32 2, i32* %1 %10 = load i32, i32* %2 %11 = load i32, i32* %1 %12 = add i32 %10, %11 store i32 %12, i32* %2 %13 = load i32, i32* %2 %14 = load i32, i32* %1 %15 = sub i32 %13, %14 %16 = add i32 %15, 0 ret i32 %16 } 输出样例 2: 0 样例 3 样例程序 3： int main() { const int sudo = 0; int rm = 5, r = 3, home = 5; sudo = rm -r /home* 0; return 0; } 输出样例 3： 编译器直接以非 0 的返回值退出。（赋值号左边的 LVal 必须是变量） "},"lab3/part6_task.html":{"url":"lab3/part6_task.html","title":"part6：调用函数","keywords":"","body":"Part 6 调用函数 在 Part 6 中，你的编译器需支持对 miniSysY 库函数的调用。 在之后的实验中，评测样例程序中会调用 miniSysY 运行时库的函数来进行输入输出。运行时库提供一系列 I/O 函数，用于在程序中表达输入/输出需求，这些库函数不用在程序中声明即可调用，你的编译器需要支持在调用这些库函数时直接翻译成对应的 LLVM IR 形式的调用，但不需要检查这些库函数参数的合法性。评测时评测机会将运行时库链接并进行评测。 在 Lab 3 中不要求支持 getarray 和 putarray 函数。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> FuncDef Decl -> ConstDecl | VarDecl ConstDecl -> 'const' BType ConstDef { ',' ConstDef } ';' BType -> 'int' ConstDef -> Ident '=' ConstInitVal ConstInitVal -> ConstExp ConstExp -> AddExp VarDecl -> BType VarDef { ',' VarDef } ';' VarDef -> Ident | Ident '=' InitVal InitVal -> Exp FuncDef -> FuncType Ident '(' ')' Block // 保证当前 Ident 只为 \"main\" FuncType -> 'int' Block -> '{' { BlockItem } '}' BlockItem -> Decl | Stmt Stmt -> LVal '=' Exp ';' | [Exp] ';' | 'return' Exp ';' Exp -> AddExp LVal -> Ident PrimaryExp -> '(' Exp ')' | LVal | Number AddExp -> MulExp | AddExp ('+' | '−') MulExp MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp UnaryExp -> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp FuncRParams -> Exp { ',' Exp } UnaryOp -> '+' | '-' 语义约束 对库函数以外未定义的函数的调用应当报错，对函数的调用传入的实参列表与函数的形参列表长度或类型不匹配时应当报错。 运行时库的函数 int getint();：输入一个整数，返回对应的整数值。int n; n = getint(); int getch();：输入一个字符，返回字符对应的 ASCII 码值。int n; n = getch(); int getarray(int []);：输入一串整数，第 1 个整数代表后续要输入的整数个数，该个数通过返回值返回；后续的整数通过传入的数组参数返回。getarray() 不会检查调用者提供的数组是否有足够的空间容纳输入的一串整数。int a[10][10]; int n; n = getarray(a[0]); void putint(int);：输出一个整数的值。int n = 10; putint(n); putint(11); void putch(int);：输出一个 ASCII 码对应的字符。传入的整数参数取值范围为 0~255。int n = 10; putch(n); void putarray(int, int[]); 第 1 个参数表示要输出的整数个数（假设为 N），后面应该跟上要输出的 N 个整数的数组。putarray() 在输出时会在整数之间安插空格。int n = 2; int a[2] = {2, 3}; putarray(n, a); 示例 样例 1 样例程序 1： int main() { int n = getint(); putint(n + 4); return 0; } 示例 IR 1： declare i32 @getint() declare void @putint(i32) define dso_local i32 @main(){ %1 = alloca i32 %2 = call i32 @getint() store i32 %2, i32* %1 %3 = load i32, i32* %1 %4 = add i32 %3, 4 call void @putint(i32 %4) ret i32 0 } 输入样例 1： 4 输出样例 1： 8 样例 2 样例程序 2： int main() { int a = getch(), b; b = getch(); putch(a); putch(b); putch(10); putch(a - 16); putch(b + 6); return 0; } 示例 IR 2： declare i32 @getch() declare void @putch(i32) define dso_local i32 @main(){ %1 = alloca i32 %2 = alloca i32 %3 = call i32 @getch() store i32 %3, i32* %2 %4 = call i32 @getch() store i32 %4, i32* %1 %5 = load i32, i32* %2 call void @putch(i32 %5) %6 = load i32, i32* %1 call void @putch(i32 %6) call void @putch(i32 10) %7 = load i32, i32* %2 %8 = sub i32 %7, 16 call void @putch(i32 %8) %9 = load i32, i32* %1 %10 = add i32 %9, 6 call void @putch(i32 %10) ret i32 0 } 输入样例 2： tl 输出样例 2： tl dr 样例 3 样例程序 3： int main() { int a = getint(); putint(); return 0; } 输出样例 3： 编译器直接以非 0 的返回值退出。 "},"lab3/help.html":{"url":"lab3/help.html","title":"实验指导","keywords":"","body":"Lab 3 实验指导 为什么示例 IR 中使用 alloca、store 和 load LLVM IR SSA 介绍 在本地调试带有库函数的 LLVM IR lli 仅能运行单个 .ll 文件，当我们想要使用别的库的时候，就需要用到 llvm-link。 在本实验中，我们引入了 libsysy 库（在 这里 可以看到）为我们的程序提供 IO 方面的操作。 /* libsysy.c */ #include \"libsysy.h\" #include /* Input & output functions */ int getint() { int t; scanf(\"%d\", &t); return t; } int getch() { char c; scanf(\"%c\", &c); return (int)c; } int getarray(int a[]) { int n; scanf(\"%d\", &n); for (int i = 0; i /* libsysy.h */ #ifndef __SYLIB_H_ #define __SYLIB_H_ #include #include #include /* Input & output functions */ int getint(), getch(), getarray(int a[]); void putint(int a), putch(int a), putarray(int n, int a[]); #endif 你需要使用 clang 将 libsysy.c 编译成 .ll 文件，然后使用 llvm-link 与你想要运行的调用 miniSysY 运行时库函数的 .ll 文件链接，生成新的 LLVM IR，再使用 lli 解释执行。 例如： ; main.ll declare i32 @getint() declare void @putint(i32) define dso_local i32 @main(){ %1 = alloca i32 %2 = call i32 @getint() store i32 %2, i32* %1 %3 = load i32, i32* %1 %4 = add i32 %3, 4 call void @putint(i32 %4) ret i32 0 } $ clang -emit-llvm -S libsysy.c -o lib.ll $ ./你的编译器 main.sy -o main.ll $ llvm-link main.ll lib.ll -S -o out.ll $ lli out.ll "},"lab3/judge.html":{"url":"lab3/judge.html","title":"评测说明","keywords":"","body":"评测说明 本次实验的评测标识符为 lab3，即你的 judge.toml 第一行应改为 [jobs.lab3]。 你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 # 一个示例 [jobs.lab3] image = { source = \"dockerfile\", path = \".\" } run = [ \"./compiler $input $ir\", ] 如果编译过程中出现了错误（语法、语义、编译过程错误等），你的编译器应当以非 0 的返回值退出（或抛出异常）。否则如果一切正常，你的编译器应当正常退出。 "},"lab4/lab4.html":{"url":"lab4/lab4.html","title":"lab 4：条件语句","keywords":"","body":"Lab 4：if 语句和条件表达式 本次实验包括两个部分，你的编译器需要在 lab 3 的基础上支持 if、else 条件判断及条件表达式。 实验评测截止时间：2022 年 1 月 2 日 23:59 实验报告命名格式：学号_姓名_lab4.pdf 实验报告提交：北航云盘 lab4：条件语句/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"lab4/part7_task.html":{"url":"lab4/part7_task.html","title":"part7：if 语句与条件表达式","keywords":"","body":"Part 7 if 语句和条件表达式 本次实验中，你的编译器需要支持 if、else 条件分支语句以及条件表达式。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> FuncDef Decl -> ConstDecl | VarDecl ConstDecl -> 'const' BType ConstDef { ',' ConstDef } ';' BType -> 'int' ConstDef -> Ident '=' ConstInitVal ConstInitVal -> ConstExp ConstExp -> AddExp VarDecl -> BType VarDef { ',' VarDef } ';' VarDef -> Ident | Ident '=' InitVal InitVal -> Exp FuncDef -> FuncType Ident '(' ')' Block // 保证当前 Ident 只为 \"main\" FuncType -> 'int' Block -> '{' { BlockItem } '}' BlockItem -> Decl | Stmt Stmt -> LVal '=' Exp ';' | Block | [Exp] ';' | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] | 'return' Exp ';' // [changed] Exp -> AddExp Cond -> LOrExp // [new] LVal -> Ident PrimaryExp -> '(' Exp ')' | LVal | Number UnaryExp -> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp UnaryOp -> '+' | '-' | '!' // 保证 '!' 只出现在 Cond 中 [changed] FuncRParams -> Exp { ',' Exp } MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp AddExp -> MulExp | AddExp ('+' | '-') MulExp RelExp -> AddExp | RelExp ('' | '=') AddExp // [new] EqExp -> RelExp | EqExp ('==' | '!=') RelExp // [new] LAndExp -> EqExp | LAndExp '&&' EqExp // [new] LOrExp -> LAndExp | LOrExp '||' LAndExp // [new] 注： Cond 中的短路求值在基础实验中不作要求，挑战实验中会有相关内容。 本部分的测试用例中不会出现对 Stmt -> Block 的变量作用域、生命周期等相关的考察。 Stmt 中的 if 语句遵循就近匹配，即 if if else 等同于 if { if else }。 值不为 0 的 Cond 表示 true，值为 0 的 Cond 表示 false。 示例 示例 IR 中的基本块跳转有点乱，是历史遗留问题 样例 1 样例程序 1： int main() { int a = getint(); int b = getint(); if (a 示例 IR 1： declare i32 @getint() declare void @putint(i32) define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 %3 = call i32 @getint() store i32 %3, i32* %2 %4 = call i32 @getint() store i32 %4, i32* %1 %5 = load i32, i32* %2 %6 = load i32, i32* %1 %7 = icmp sle i32 %5, %6 br i1 %7,label %8, label %10 8: call void @putint(i32 1) br label %9 9: ret i32 0 10: call void @putint(i32 0) br label %9 } 输入样例 1： 9 12 输出样例 1： 1 样例 2 样例程序 2： int main() { int a, b, c = 1, d; int result; a = 5; b = 5; d = -2; result = 2; if (a + b + c + d == 10) { result = result + 1; } else if (a + b + c + d == 8) { result = result + 2; } else { result = result + 4; } putint(result); return 0; } 示例 IR 2： declare void @putint(i32) define dso_local i32 @main(){ %1 = alloca i32 %2 = alloca i32 %3 = alloca i32 %4 = alloca i32 %5 = alloca i32 store i32 1, i32* %3 store i32 5, i32* %5 store i32 5, i32* %4 %6 = sub i32 0, 2 store i32 %6, i32* %2 store i32 2, i32* %1 %7 = load i32, i32* %5 %8 = load i32, i32* %4 %9 = add i32 %7, %8 %10 = load i32, i32* %3 %11 = add i32 %9, %10 %12 = load i32, i32* %2 %13 = add i32 %11, %12 %14 = icmp eq i32 %13, 10 br i1 %14, label %29, label %20 15: %16 = load i32, i32* %1 %17 = add i32 %16, 1 store i32 %17, i32* %1 br label %18 18: %19 = load i32, i32* %1 call void @putint(i32 %19) ret i32 0 20: %21 = load i32, i32* %5 %22 = load i32, i32* %4 %23 = add i32 %21, %22 %24 = load i32, i32* %3 %25 = add i32 %23, %24 %26 = load i32, i32* %2 %27 = add i32 %25, %26 %28 = icmp eq i32 %27, 8 br i1 %28, label %37, label %34 29: br label %15 30: %31 = load i32, i32* %1 %32 = add i32 %31, 2 store i32 %32, i32* %1 br label %33 33: br label %18 34: %35 = load i32, i32* %1 %36 = add i32 %35, 4 store i32 %36, i32* %1 br label %33 37: br label %30 } 输出样例 2： 6 样例 3 样例程序 3： int main() { int a, b, c = 1, d; int result; a = 5; b = 5; d = -2; result = 2; if (a + b == 9 || a - b == 0 && result != 4) result = result + 3; else if (c + d != -1 || (result + 1) % 2 == 1) result = result + 4; putint(result); return 0; } 示例 IR 3： declare void @putint(i32) define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 %3 = alloca i32 %4 = alloca i32 %5 = alloca i32 store i32 1, i32* %3 store i32 5, i32* %5 store i32 5, i32* %4 %6 = sub i32 0, 2 store i32 %6, i32* %2 store i32 2, i32* %1 %7 = load i32, i32* %5 %8 = load i32, i32* %4 %9 = add i32 %7, %8 %10 = icmp eq i32 %9, 9 br i1 %10, label %27, label %22 11: %12 = load i32, i32* %1 %13 = add i32 %12, 3 store i32 %13, i32* %1 br label %14 14: %15 = load i32, i32* %1 call void @putint(i32 %15) ret i32 0 16: %17 = load i32, i32* %3 %18 = load i32, i32* %2 %19 = add i32 %17, %18 %20 = sub i32 0, 1 %21 = icmp ne i32 %19, %20 br i1 %21, label %41, label %36 22: %23 = load i32, i32* %5 %24 = load i32, i32* %4 %25 = sub i32 %23, %24 %26 = icmp eq i32 %25, 0 br i1 %26, label %28, label %16 27: br label %11 28: %29 = load i32, i32* %1 %30 = icmp ne i32 %29, 4 br i1 %30, label %31, label %16 31: br label %11 32: %33 = load i32, i32* %1 %34 = add i32 %33, 4 store i32 %34, i32* %1 br label %35 35: br label %14 36: %37 = load i32, i32* %1 %38 = add i32 %37, 1 %39 = srem i32 %38, 2 %40 = icmp eq i32 %39, 1 br i1 %40, label %42, label %35 41: br label %32 42: br label %32 } 输出样例 3： 5 样例 4 样例程序 4： int main() { int a; a = 10; if (+-!!!a) { a = - - -1; } else { a = 0; } putint(a); return 0; } 示例 IR 4： declare void @putint(i32) define dso_local i32 @main() { %1 = alloca i32 store i32 10, i32* %1 %2 = load i32, i32* %1 %3 = icmp eq i32 %2, 0 %4 = zext i1 %3 to i32 %5 = icmp eq i1 %3, 0 %6 = zext i1 %5 to i32 %7 = icmp eq i1 %5, 0 %8 = zext i1 %7 to i32 %9 = zext i1 %7 to i32 %10 = sub i32 0, %9 %11 = icmp ne i32 %10, 0 br i1 %11, label %12, label %18 12: %13 = sub i32 0, 1 %14 = sub i32 0, %13 %15 = sub i32 0, %14 store i32 %15, i32* %1 br label %16 16: %17 = load i32, i32* %1 call void @putint(i32 %17) ret i32 0 18: store i32 0, i32* %1 br label %16 } 输出样例 4： 0 "},"lab4/help.html":{"url":"lab4/help.html","title":"实验指导","keywords":"","body":"Lab 4 实验指导 基本块 基本块相关知识会在课程“代码优化”一章中系统地学习到。 基本块是一段顺序执行的的指令，控制流只能从一个基本块的第一条指令开始执行，从最后一条指令退出基本块，或是跳转到其他基本块（包括自己）的第一条指令，或是退出程序。基本块的最后一条指令必须是一个跳转指令或返回指令，且中间不会出现跳转和返回指令。 之前的实验中，你生成的 LLVM IR 其实就是在一个基本块中的，从第一条指令开始执行，直到最后一条 ret 指令退出运行。而在 Lab 4 中，我们引入了 if 和 else，这使得程序不再是按照 IR 一条一条地顺序执行下去，IR 需要划分成多个不同的基本块，控制流在这些基本块之间跳转。 以下面一段代码为例： int main() { int a = getint(); if (a == 1) { putint(1); } else { putint(2); } return 0; } declare i32 @getint() declare void @putint(i32) define dso_local i32 @main() { %1 = alloca i32 %2 = call i32 @getint() store i32 %2, i32* %1 %3 = load i32, i32* %1 %4 = icmp eq i32 %3, 1 br i1 %4, label %5, label %6 5: call void @putint(i32 1) br label %7 6: call void @putint(i32 2) br label %7 7: ret i32 0 } 代码中共有 4 个基本块，第一个基本块被隐式命名成了 0（当然你也可以显式地给它命名），第一个基本块中包括了一条 icmp 指令和一条 br 指令，icmp 指令将 a 和 1 比较，结果存放在 %4 中，br 指令是一个条件跳转指令，当 %4 为 true 时跳转到 5，%4 为 false 时跳转到 6。5 和 6 的 br 指令是无条件跳转，即执行到这里后直接跳转到 7。 再次强调：clang 默认生成的虚拟寄存器是按数字顺序命名的，LLVM 限制了所有数字命名的虚拟寄存器必须严格地从 0 开始递增，且每个函数参数和基本块都会占用一个编号。如果你不能确定怎样用数字命名虚拟寄存器，请使用字符串命名虚拟寄存器。 LLVM IR 指令指导 在这里 推荐指令 你可以回顾之前介绍到的在本次实验中出现的一些新指令。 本次 lab 中将会出现多个基本块，这意味着你需要配合使用zext,and,or和icmp指令来完成控制流在基本块之间的跳转。 LLVM IR 中，如果想要将一个 i1类型的变量转换为i32类型的变量，你必须使用zext指令来进行显式的类型转换。 zext指令的使用方法是 = zext to , 下面是一个简单的例子 define i32 @main() { %x = add i1 0,0 %x1 = zext i1 %x to i32 ret i32 %x1 } icmp是比较指令，它的使用方法是 = icmp , ，需要注意的是，icmp的是i1的。 and和or是按位与/或指令 = and/or , ，将被用来实现较复杂条件语句的运算。 br是跳转指令，分为无条件和有条件两种情况，br i1 , label , label （有条件跳转），br label （无条件跳转） 下面是一个简单的例子 define i32 @main() { block_a: %x=add i32 0,123 %y=add i32 0,321 ; %m=add i32 0,123 %n=add i32 0,123 ; %res_xy = icmp eq i32 %x,%y %res_mn = icmp eq i32 %m,%n %cond = and i1 %res_xy,%res_mn; 你可以把 and 改成 or 看有什么变化 br i1 %cond ,label %block_true,label %block_false block_true: ret i32 0 block_false: ret i32 1 } 用c语言的逻辑，这段代码的意思大概是这样的 if((x==y)&&(m==n)){ return 0; } return 1; "},"lab4/judge.html":{"url":"lab4/judge.html","title":"评测说明","keywords":"","body":"评测说明 本次实验的评测标识符为 lab4，即你的 judge.toml 第一行应改为 [jobs.lab4]。 你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 # 一个示例 [jobs.lab4] image = { source = \"dockerfile\", path = \".\" } run = [ \"./compiler $input $ir\", ] 如果编译过程中出现了错误（语法、语义、编译过程错误等），你的编译器应当以非 0 的返回值退出（或抛出异常）。否则如果一切正常，你的编译器应当正常退出。 "},"lab5/lab5.html":{"url":"lab5/lab5.html","title":"lab 5：作用域与全局变量","keywords":"","body":"Lab 5：作用域和全局变量 本次实验包括两个部分，你的编译器需要在 lab 4 的基础上支持变量作用域的一些区分及全局变量 实验评测截止时间：2022 年 1 月 2 日 23:59 实验报告命名格式：学号_姓名_lab5.pdf 实验报告提交：北航云盘 lab5：作用域和全局变量/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"lab5/part8_task.html":{"url":"lab5/part8_task.html","title":"part8：作用域与块","keywords":"","body":"Part 8 作用域与块 在 Part 8 中，你的编译器需要完善对语句块和作用域的语义支持。 语法规则没有变化。 语义约束 Block Block 表示语句块。语句块会创建作用域，语句块内声明的变量的生命周期在该语句块内。 同一作用域中不能有同名的变量或常量。 语句块内可以再次定义与语句块外同名的变量或常量（通过 Decl 语句)，其作用域从定义处开始到该语句块尾结束，它隐藏语句块外的同名变量或常量。 示例 样例 1 样例程序 1： int main() { int a = getint(); { int b = 2; putint(a + b); int a = getint(); putint(a + b); } int b = a + 2; putint(a + b); return 0; } 示例 IR 1： declare i32 @getint() declare void @putint(i32) define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 %3 = alloca i32 %4 = alloca i32 %5 = call i32 @getint() store i32 %5, i32* %4 store i32 2, i32* %3 %6 = load i32, i32* %4 %7 = load i32, i32* %3 %8 = add i32 %6, %7 call void @putint(i32 %8) %9 = call i32 @getint() store i32 %9, i32* %2 %10 = load i32, i32* %2 %11 = load i32, i32* %3 %12 = add i32 %10, %11 call void @putint(i32 %12) %13 = load i32, i32* %4 %14 = add i32 %13, 2 store i32 %14, i32* %1 %15 = load i32, i32* %4 %16 = load i32, i32* %1 %17 = add i32 %15, %16 call void @putint(i32 %17) ret i32 0 } 输入样例 1： 1 5 输出样例 1： 374 样例 2 样例程序 2： int main() { const int c1 = 10 * 5 / 2; const int c2 = c1 / 2, c3 = c1 * 2; if (c1 > 24) { int c1 = 24; putint(c2 - c1 * c3); putch(10); } { int c2 = c1 / 4; putint(c3 / c2); { int c3 = c1 * 4; putint(c3 / c2); } } putch(10); putint(c3 / c2); return 0; } 示例 IR 2： declare void @putint(i32) declare void @putch(i32) define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 %3 = alloca i32 %4 = icmp sgt i32 25, 24 br i1 %4, label %5, label %9 5: store i32 24, i32* %3 %6 = load i32, i32* %3 %7 = mul i32 %6, 50 %8 = sub i32 12, %7 call void @putint(i32 %8) call void @putch(i32 10) br label %9 9: %10 = sdiv i32 25, 4 store i32 %10, i32* %2 %11 = load i32, i32* %2 %12 = sdiv i32 50, %11 call void @putint(i32 %12) %13 = mul i32 25, 4 store i32 %13, i32* %1 %14 = load i32, i32* %1 %15 = load i32, i32* %2 %16 = sdiv i32 %14, %15 call void @putint(i32 %16) call void @putch(i32 10) %17 = sdiv i32 50, 12 call void @putint(i32 %17) ret i32 0 } 输出样例 2: -1188 816 4 样例 3 样例程序 3： int main() { int a = 1; int a = 2; return 0; } 输出样例 3： 编译器直接以非 0 的返回值退出。 "},"lab5/part9_task.html":{"url":"lab5/part9_task.html","title":"part⑨：全局变量","keywords":"","body":"Part ⑨ 全局变量 在 Part ⑨ 中，你的编译器需要支持全局变量。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> Decl* FuncDef // [changed] Decl -> ConstDecl | VarDecl ConstDecl -> 'const' BType ConstDef { ',' ConstDef } ';' BType -> 'int' ConstDef -> Ident '=' ConstInitVal ConstInitVal -> ConstExp ConstExp -> AddExp VarDecl -> BType VarDef { ',' VarDef } ';' VarDef -> Ident | Ident '=' InitVal InitVal -> Exp FuncDef -> FuncType Ident '(' ')' Block // 保证当前 Ident 只为 \"main\" FuncType -> 'int' Block -> '{' { BlockItem } '}' BlockItem -> Decl | Stmt Stmt -> LVal '=' Exp ';' | Block | [Exp] ';' | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] | 'return' Exp ';' Exp -> AddExp Cond -> LOrExp LVal -> Ident PrimaryExp -> '(' Exp ')' | LVal | Number UnaryExp -> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp UnaryOp -> '+' | '-' | '!' // 保证 '!' 只出现在 Cond 中 FuncRParams -> Exp { ',' Exp } MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp AddExp -> MulExp | AddExp ('+' | '-') MulExp RelExp -> AddExp | RelExp ('' | '=') AddExp EqExp -> RelExp | EqExp ('==' | '!=') RelExp LAndExp -> EqExp | LAndExp '&&' EqExp LOrExp -> LAndExp | LOrExp '||' LAndExp 语义约束 ConstDef 和 VarDef 全局变量之间不允许同名； ConstInitVal 和 InitVal 全局变/常量声明中指定的初值表达式必须是常量表达式； 局部变量可以和全局变量同名，在局部变量作用域内，局部变量隐藏了同名全局变量的定义； 未显式初始化的局部变量，其值是不确定的；而未显式初始化的全局变量，其值均被初始化为 0。 示例 样例 1 样例程序 1： int a = 5; int main() { int b = getint(); putint(a + b); return 0; } 示例 IR 1： @a = dso_local global i32 5 declare i32 @getint() declare void @putint(i32) define dso_local i32 @main() { %1 = alloca i32 %2 = call i32 @getint() store i32 %2, i32* %1 %3 = load i32, i32* @a %4 = load i32, i32* %1 %5 = add i32 %3, %4 call void @putint(i32 %5) ret i32 0 } 输入样例 1： 4 输出样例 1： 9 样例 2 样例程序 2： const int a = 6; int b = a + 1; int main() { int c = b; int b = 8; putint(b + c); return 0; } 示例 IR 2： @b = dso_local global i32 7 declare i32 @getint() declare void @putint(i32) define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 %3 = load i32, i32* @b store i32 %3, i32* %2 store i32 8, i32* %1 %4 = load i32, i32* %1 %5 = load i32, i32* %2 %6 = add i32 %4, %5 call void @putint(i32 %6) ret i32 0 } 输出样例 2： 15 样例 3 样例程序 3： int a = 6; int b = a + 1; int main() { int c = b; int b = 8; putint(b + c); return 0; } 输出样例 3： 编译器直接以非 0 的返回值退出。 "},"lab5/judge.html":{"url":"lab5/judge.html","title":"评测说明","keywords":"","body":"评测说明 本次实验的评测标识符为 lab5，即你的 judge.toml 第一行应改为 [jobs.lab5]。 你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 # 一个示例 [jobs.lab5] image = { source = \"dockerfile\", path = \".\" } run = [ \"./compiler $input $ir\", ] 如果编译过程中出现了错误（语法、语义、编译过程错误等），你的编译器应当以非 0 的返回值退出（或抛出异常）。否则如果一切正常，你的编译器应当正常退出。 "},"lab6/lab6.html":{"url":"lab6/lab6.html","title":"lab 6：循环","keywords":"","body":"Lab 6：循环 本次实验要求你的编译器在 lab 5 的基础上支持 while 循环、continue 和 break 语句。 实验评测截止时间：2022 年 1 月 7 日 23:59 实验报告命名格式：学号_姓名_lab6.pdf 实验报告提交：北航云盘 lab6：循环/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"lab6/part10_task.html":{"url":"lab6/part10_task.html","title":"part10：循环语句","keywords":"","body":"Part 10 循环语句 在 Part 10 中，你的编译器需要支持 while 循环。 保证测试用例在正确的控制流下不会出现死循环。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> Decl* FuncDef Decl -> ConstDecl | VarDecl ConstDecl -> 'const' BType ConstDef { ',' ConstDef } ';' BType -> 'int' ConstDef -> Ident '=' ConstInitVal ConstInitVal -> ConstExp ConstExp -> AddExp VarDecl -> BType VarDef { ',' VarDef } ';' VarDef -> Ident | Ident '=' InitVal InitVal -> Exp FuncDef -> FuncType Ident '(' ')' Block // 保证当前 Ident 只为 \"main\" FuncType -> 'int' Block -> '{' { BlockItem } '}' BlockItem -> Decl | Stmt Stmt -> LVal '=' Exp ';' | Block | [Exp] ';' | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] | 'while' '(' Cond ')' Stmt | 'return' Exp ';' // [changed] Exp -> AddExp Cond -> LOrExp LVal -> Ident PrimaryExp -> '(' Exp ')' | LVal | Number UnaryExp -> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp UnaryOp -> '+' | '-' | '!' // 保证 '!' 只出现在 Cond 中 FuncRParams -> Exp { ',' Exp } MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp AddExp -> MulExp | AddExp ('+' | '-') MulExp RelExp -> AddExp | RelExp ('' | '=') AddExp EqExp -> RelExp | EqExp ('==' | '!=') RelExp LAndExp -> EqExp | LAndExp '&&' EqExp LOrExp -> LAndExp | LOrExp '||' LAndExp 示例 示例 IR 中的基本块跳转有点乱，是历史遗留问题 样例 1 样例程序 1： int main() { int n = getint(); int i = 0, sum = 0; while (i 示例 IR 1： declare i32 @getint() declare void @putint(i32) declare void @putch(i32) define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 %3 = alloca i32 %4 = call i32 @getint() store i32 %4, i32* %3 store i32 0, i32* %2 store i32 0, i32* %1 br label %5 5: %6 = load i32, i32* %2 %7 = load i32, i32* %3 %8 = icmp slt i32 %6, %7 br i1 %8, label %9, label %16 9: %10 = load i32, i32* %2 %11 = add i32 %10, 1 store i32 %11, i32* %2 %12 = load i32, i32* %1 %13 = load i32, i32* %2 %14 = add i32 %12, %13 store i32 %14, i32* %1 %15 = load i32, i32* %1 call void @putint(i32 %15) call void @putch(i32 10) br label %5 16: ret i32 0 } 输入样例 1： 5 输出样例 1： 1 3 6 10 15 样例 2 样例程序 2： int main() { const int ch = 48; int i = 1; while (i 示例 IR 2： declare void @putch(i32 ) define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 store i32 1, i32* %2 br label %3 3: %4 = load i32, i32* %2 %5 = icmp slt i32 %4, 12 br i1 %5, label %8, label %7 6: store i32 0, i32* %1 br label %9 7: ret i32 0 8: br label %6 9: %10 = load i32, i32* %1 %11 = load i32, i32* %2 %12 = mul i32 2, %11 %13 = sub i32 %12, 1 %14 = icmp slt i32 %10, %13 br i1 %14, label %24, label %21 15: %16 = load i32, i32* %1 %17 = sdiv i32 %16, 3 %18 = mul i32 %17, 3 %19 = sub i32 %16, %18 %20 = icmp eq i32 %19, 1 br i1 %20, label %31, label %30 21: call void @putch(i32 10) %22 = load i32, i32* %2 %23 = add i32 %22, 1 store i32 %23, i32* %2 br label %3 24: br label %15 25: %26 = add i32 48, 1 call void @putch(i32 %26) br label %27 27: %28 = load i32, i32* %1 %29 = add i32 %28, 1 store i32 %29, i32* %1 br label %9 30: call void @putch(i32 48) br label %27 31: br label %25 } 输出样例 2: 0 010 01001 0100100 010010010 01001001001 0100100100100 010010010010010 01001001001001001 0100100100100100100 010010010010010010010 "},"lab6/part11_task.html":{"url":"lab6/part11_task.html","title":"part11：continue、break 与代码回填","keywords":"","body":"Part 11 continue、break 与代码回填 在 Part 11 中，你的编译器需要支持循环中的 continue、break 语句。 continue、break 不会出现在循环外。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> Decl* FuncDef Decl -> ConstDecl | VarDecl ConstDecl -> 'const' BType ConstDef { ',' ConstDef } ';' BType -> 'int' ConstDef -> Ident '=' ConstInitVal ConstInitVal -> ConstExp ConstExp -> AddExp VarDecl -> BType VarDef { ',' VarDef } ';' VarDef -> Ident | Ident '=' InitVal InitVal -> Exp FuncDef -> FuncType Ident '(' ')' Block // 保证当前 Ident 只为 \"main\" FuncType -> 'int' Block -> '{' { BlockItem } '}' BlockItem -> Decl | Stmt Stmt -> LVal '=' Exp ';' | Block | [Exp] ';' | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] | 'while' '(' Cond ')' Stmt | 'break' ';' | 'continue' ';' | 'return' Exp ';' // [changed] Exp -> AddExp Cond -> LOrExp LVal -> Ident PrimaryExp -> '(' Exp ')' | LVal | Number UnaryExp -> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp UnaryOp -> '+' | '-' | '!' // 保证 '!' 只出现在 Cond 中 FuncRParams -> Exp { ',' Exp } MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp AddExp -> MulExp | AddExp ('+' | '-') MulExp RelExp -> AddExp | RelExp ('' | '=') AddExp EqExp -> RelExp | EqExp ('==' | '!=') RelExp LAndExp -> EqExp | LAndExp '&&' EqExp LOrExp -> LAndExp | LOrExp '||' LAndExp 示例 示例 IR 中的基本块跳转有点乱，是历史遗留问题 样例 1 样例程序 1： int main() { int n = getint(); int i = 0, sum = 0; while (i 示例 IR 1： declare i32 @getint() declare void @putint(i32 ) declare void @putch(i32 ) define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 %3 = alloca i32 %4 = call i32 @getint() store i32 %4, i32* %3 store i32 0, i32* %2 store i32 0, i32* %1 br label %5 5: %6 = load i32, i32* %2 %7 = load i32, i32* %3 %8 = icmp slt i32 %6, %7 br i1 %8, label %14, label %13 9: %10 = load i32, i32* %2 %11 = srem i32 %10, 2 %12 = icmp eq i32 %11, 0 br i1 %12, label %25, label %18 13: ret i32 0 14: br label %9 15: %16 = load i32, i32* %2 %17 = add i32 %16, 1 store i32 %17, i32* %2 br label %5 18: %19 = load i32, i32* %2 %20 = add i32 %19, 1 store i32 %20, i32* %2 %21 = load i32, i32* %1 %22 = load i32, i32* %2 %23 = add i32 %21, %22 store i32 %23, i32* %1 %24 = load i32, i32* %1 call void @putint(i32 %24) call void @putch(i32 10) br label %5 25: br label %15 } 输入样例 1： 10 输出样例 1： 2 6 12 20 30 样例 2 样例程序 2： int main() { const int ch = 48; int i = 1; while (i = 2 * i - 1) break; } putch(10); i = i + 1; continue; // something meaningless } return 0; } 示例 IR 2： declare void @putch(i32 ) define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 store i32 1, i32* %2 br label %3 3: %4 = load i32, i32* %2 %5 = icmp slt i32 %4, 12 br i1 %5, label %8, label %7 6: store i32 0, i32* %1 br label %9 7: ret i32 0 8: br label %6 9: %10 = icmp eq i32 1, 1 br i1 %10, label %18, label %15 11: %12 = load i32, i32* %1 %13 = srem i32 %12, 3 %14 = icmp eq i32 %13, 1 br i1 %14, label %30, label %29 15: call void @putch(i32 10) %16 = load i32, i32* %2 %17 = add i32 %16, 1 store i32 %17, i32* %2 br label %3 18: br label %11 19: %20 = add i32 48, 1 call void @putch(i32 %20) br label %21 21: %22 = load i32, i32* %1 %23 = add i32 %22, 1 store i32 %23, i32* %1 %24 = load i32, i32* %1 %25 = load i32, i32* %2 %26 = mul i32 2, %25 %27 = sub i32 %26, 1 %28 = icmp sge i32 %24, %27 br i1 %28, label %33, label %32 29: call void @putch(i32 48) br label %21 30: br label %19 31: br label %15 32: br label %9 33: br label %31 } 输出样例 2： 0 010 01001 0100100 010010010 01001001001 0100100100100 010010010010010 01001001001001001 0100100100100100100 010010010010010010010 "},"lab6/help.html":{"url":"lab6/help.html","title":"实验指导","keywords":"","body":"Lab 6 实验指导 更为正式的语言你可以在龙书等书本上找到，比如龙书的第六章第七节，这个指导的目的是让你理解回填存在的意义和作用。 基本思想：在生成一些跳转指令时，暂时不指定这个指令跳转的目标位置，而是将其放入一个容器中暂时存储，在能确定正确的目标标号以后，再去填充这个容器内的指令的目标标号。 为什么需要这么做呢，举个简单的例子 while (cond_a) { if (cond_b) { break; } do_some_thing(); } some_other_things(); 以上述代码为例，在一趟式的翻译中（边分析边推导边生成代码或者先生成 AST 再遍历 AST 来生成代码），我们必须在处理 some_other_things(); 之前完成对 while 语句中的内容的处理，而我们在分析到 break 的时候，并不知道我们生成的 br 指令应该跳转到哪个基本块（通常这个块还没有生成）。这时我们就需要一个记录来记录下“此处应有一个跳出去的 br”，然后把这个记录存起来，继续向下分析。 当分析结束，我们到达了some_other_things(); 后，我们就知道了那些未确定的 br 指令应该跳转的地方，然后我们按图索骥，按照记录去找到这些需要被更新的指令，至此，我们就完成了一次“回填”。 实现的思路：你的编译器中肯定是有类似于 analyseWhileStmt() 或者 visitWhileStmt() 的函数的，你可以在进入这个函数时生成一个容器，用于记录接下来可能出现的 break 和 continue，在其出现以后生成一个临时的占位符，并将这个占位符的位置存储到容器中，在退出这个函数前遍历这个容器，将那些位置替换为正确的跳转。 伪代码如下： Stack stk = new Stack(); visitWhileStmt() { stk.push(new Recorder()); // do some thing stk.top.foreach(mark -> { update(mark); }); stk.pop(); } visitBreakStmt() { stk.top.record(new Mark(\"break\")); } visitContinueStmt() { stk.top.record(new Mark(\"continue\")); } 使用 Stack 是因为循环会出现嵌套。 "},"lab6/judge.html":{"url":"lab6/judge.html","title":"评测说明","keywords":"","body":"评测说明 本次实验的评测标识符为 lab6，即你的 judge.toml 第一行应改为 [jobs.lab6]。 你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 # 一个示例 [jobs.lab6] image = { source = \"dockerfile\", path = \".\" } run = [ \"./compiler $input $ir\", ] 如果编译过程中出现了错误（语法、语义、编译过程错误等），你的编译器应当以非 0 的返回值退出（或抛出异常）。否则如果一切正常，你的编译器应当正常退出。 "},"lab7/lab7.html":{"url":"lab7/lab7.html","title":"lab 7：数组","keywords":"","body":"Lab 7：数组 本次实验要求你的编译器在 lab 6 的基础上支持一维数组和二维数组。 实验评测截止时间：2022 年 1 月 7 日 23:59 实验报告命名格式：学号_姓名_lab7.pdf 实验报告提交：北航云盘 lab7：数组/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"lab7/part12_task.html":{"url":"lab7/part12_task.html","title":"part12：一维数组、二维数组","keywords":"","body":"Part 12 一维数组、二维数组 在 Part 12 中，你的编译器需要支持一维数组和二维数组。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> Decl* FuncDef Decl -> ConstDecl | VarDecl ConstDecl -> 'const' BType ConstDef { ',' ConstDef } ';' BType -> 'int' ConstDef -> Ident { '[' ConstExp ']' } '=' ConstInitVal // [changed] ConstInitVal -> ConstExp | '{' [ ConstInitVal { ',' ConstInitVal } ] '}' // [changed] ConstExp -> AddExp VarDecl -> BType VarDef { ',' VarDef } ';' VarDef -> Ident { '[' ConstExp ']' } | Ident { '[' ConstExp ']' } '=' InitVal // [changed] InitVal -> Exp | '{' [ InitVal { ',' InitVal } ] '}' // [changed] FuncDef -> FuncType Ident '(' ')' Block // 保证当前 Ident 只为 \"main\" FuncType -> 'int' Block -> '{' { BlockItem } '}' BlockItem -> Decl | Stmt Stmt -> LVal '=' Exp ';' | Block | [Exp] ';' | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] | 'while' '(' Cond ')' Stmt | 'break' ';' | 'continue' ';' | 'return' Exp ';' Exp -> AddExp Cond -> LOrExp LVal -> Ident {'[' Exp ']'} // [changed] PrimaryExp -> '(' Exp ')' | LVal | Number UnaryExp -> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp UnaryOp -> '+' | '-' | '!' // 保证 '!' 只出现在 Cond 中 FuncRParams -> Exp { ',' Exp } MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp AddExp -> MulExp | AddExp ('+' | '-') MulExp RelExp -> AddExp | RelExp ('' | '=') AddExp EqExp -> RelExp | EqExp ('==' | '!=') RelExp LAndExp -> EqExp | LAndExp '&&' EqExp LOrExp -> LAndExp | LOrExp '||' LAndExp 语义约束 ConstDef ConstDef 的数组维度和各维长度的定义部分存在时，表示定义数组。其语义和 C 语言一致。比如 [2 * 3][8 / 2] 表示二维数组，第一和第二维长度分别为 6 和 4，每维的下界从 0 编号。 ConstDef 中表示各维长度的 ConstExp 必须是能在编译时求值到非负整数的常量表达式。在声明数组时各维长度都需要显式给出，而不允许是未知的。 当 ConstDef 定义的是数组时，= 右边的 ConstInitVal 表示常量初始化器。全局常量数组的 ConstInitVal 中的 ConstExp 必须是常量表达式。局部常量数组的 ConstInitVal 中的 ConstExp 必须是能在编译时求值的 int 型表达式。 ConstInitVal 初始化器必须是以下三种情况之一： 一对花括号 {}，表示所有元素初始为 0； 数组维数和各维长度完全对应的初始值，如 int a[3] = {1, 2, 3};、int a[3][2] = { {1, 2}, {3, 4}, {5, 6} };； 花括号中初始值少于对应维度元素个数，该维其余部分将被隐式初始化为 0，如 int a[5] = {1, 2};、int a[4][4] = { {1, 2, 3}, {4, 5}, {} };。 VarDef VarDef 的数组维度和各维长度的定义部分存在时，表示定义数组。其语义和 C 语言一致。VarDef 中表示各维长度的 ConstExp 必须能在编译时求值到非负整数的常量表达式。在声明数组时各维长度都需要显式给出，而不允许是未知的。 全局变量数组的 InitVal 中的 Exp 必须是常量表达式。局部变量数组 InitVal 中的 Exp 可以是任何符合语义的表达式。 LVal 当 LVal 表示数组时，方括号个数必须和数组变量的维数相同（即定位到元素）。 初值的常量/可求值总结 “编译时可求值”约束为常数和 int 类型变量/常量所构成的表达式，且不包括数组元素、函数返回值。 在评测时只会针对表达式是否满足常量要求进行评测。 全局 int 类型变量/常量的初值必须是编译时可求值的常量表达式。 局部 int 类型常量的初值必须是编译时可求值的表达式。（和 C 语言略有不同） 数组的各维长度必须是编译时可求值的非负常量表达式。 全局数组的 ConstInitVal/InitVal 中的 ConstExp/Exp 必须是编译时可求值的常量表达式。 局部常量数组的 ConstInitVal 中的 ConstExp 必须是编译时可求值的表达式。（和 C 语言略有不同） 其他 数组下标越界是未定义行为，不作为编译错误考察。 LLVM IR 中数组的初始化 你可以不采用以下介绍的实现方式，自己编写测试代码并使用 clang 编译到 LLVM IR，模仿实现 clang 生成的 LLVM IR 中的数组初始化方式。 局部数组：调用 C 语言库函数 memset(pointer, 0, size * sizeof(int)) 将数组元素全部置为 0，其中 pointer 为指向数组基址的指针，size 为数组容量，sizeof(int) 为 4。然后使用 store 指令将初始化器中的元素存入数组的对应位置。 评测机已对 memset 提供支持，你可以在 IR 中声明后直接调用。 全局数组：在全局区进行相应的声明和初始化。你可以使用如下的语法对一维数组进行初始化：@arr = dso_local global [3 x i32] [i32 1, i32 2, i32 3]。对于二维数组，你需要对其中包含的每一个一维数组进行初始化：@arr = dso_local global [2 x [2 x i32]] [[2 x i32] [i32 1, i32 2], [2 x i32] [i32 3, i32 0]]。你可以使用 zeroinitializer 将一个数组中的元素全部置为 0。 示例 样例 1 样例程序 1： int main() { int a[2][2] = {{1}, {2, 3}}; int e[2][2] = {{a[0][0], a[1][1]}, {5, 6}}; putint(e[1][1] + a[1][0]); return 0; } 示例 IR 1： declare void @putint(i32) declare void @memset(i32*, i32, i32) define dso_local i32 @main() { %1 = alloca [2 x [2 x i32]] %2 = alloca [2 x [2 x i32]] %3 = getelementptr [2 x [2 x i32]], [2 x [2 x i32]]* %2, i32 0, i32 0 %4 = getelementptr [2 x i32], [2 x i32]* %3, i32 0, i32 0 call void @memset(i32* %4, i32 0, i32 16) store i32 1, i32* %4 %5 = getelementptr i32, i32* %4, i32 2 store i32 2, i32* %5 %6 = getelementptr i32, i32* %4, i32 3 store i32 3, i32* %6 %7 = getelementptr [2 x [2 x i32]], [2 x [2 x i32]]* %2, i32 0, i32 0 %8 = add i32 0, 0 %9 = mul i32 %8, 2 %10 = getelementptr [2 x i32], [2 x i32]* %7, i32 0, i32 0 %11 = add i32 %9, 0 %12 = getelementptr i32, i32* %10, i32 %11 %13 = load i32, i32* %12 %14 = getelementptr [2 x [2 x i32]], [2 x [2 x i32]]* %2, i32 0, i32 0 %15 = add i32 0, 1 %16 = mul i32 %15, 2 %17 = getelementptr [2 x i32], [2 x i32]* %14, i32 0, i32 0 %18 = add i32 %16, 1 %19 = getelementptr i32, i32* %17, i32 %18 %20 = load i32, i32* %19 %21 = getelementptr [2 x [2 x i32]], [2 x [2 x i32]]* %1, i32 0, i32 0 %22 = getelementptr [2 x i32], [2 x i32]* %21, i32 0, i32 0 call void @memset(i32* %22, i32 0, i32 16) store i32 %13, i32* %22 %23 = getelementptr i32, i32* %22, i32 1 store i32 %20, i32* %23 %24 = getelementptr i32, i32* %22, i32 2 store i32 5, i32* %24 %25 = getelementptr i32, i32* %22, i32 3 store i32 6, i32* %25 %26 = getelementptr [2 x [2 x i32]], [2 x [2 x i32]]* %1, i32 0, i32 0 %27 = add i32 0, 1 %28 = mul i32 %27, 2 %29 = getelementptr [2 x i32], [2 x i32]* %26, i32 0, i32 0 %30 = add i32 %28, 1 %31 = getelementptr i32, i32* %29, i32 %30 %32 = load i32, i32* %31 %33 = getelementptr [2 x [2 x i32]], [2 x [2 x i32]]* %2, i32 0, i32 0 %34 = add i32 0, 1 %35 = mul i32 %34, 2 %36 = getelementptr [2 x i32], [2 x i32]* %33, i32 0, i32 0 %37 = add i32 %35, 0 %38 = getelementptr i32, i32* %36, i32 %37 %39 = load i32, i32* %38 %40 = add i32 %32, %39 call void @putint(i32 %40) ret i32 0 } 输出样例 1： 8 样例 2 样例程序 2： const int c[2][1] = {{1}, {3}}; int b[2][3] = {{1}}, e[4][4]; int d[5], a[3] = {1, 2}; int main() { putint(c[1][0] + b[0][0] + c[0][0] + a[1] + d[4]); return 0; } 示例 IR 2： declare void @memset(i32* ,i32 ,i32 ) declare void @putint(i32 ) @c = dso_local constant [2 x [1 x i32]] [[1 x i32] [i32 1], [1 x i32] [i32 3]] @b = dso_local global [2 x [3 x i32]] [[3 x i32] [i32 1, i32 0, i32 0], [3 x i32] zeroinitializer] @e = dso_local global [4 x [4 x i32]] zeroinitializer @d = dso_local global [5 x i32] zeroinitializer @a = dso_local global [3 x i32] [i32 1, i32 2, i32 0] define dso_local i32 @main() { %1 = getelementptr [2 x [1 x i32]], [2 x [1 x i32]]* @c, i32 0, i32 0 %2 = add i32 0, 1 %3 = mul i32 %2, 1 %4 = getelementptr [1 x i32], [1 x i32]* %1, i32 0, i32 0 %5 = add i32 %3, 0 %6 = getelementptr i32, i32* %4, i32 %5 %7 = load i32, i32* %6 %8 = getelementptr [2 x [3 x i32]], [2 x [3 x i32]]* @b, i32 0, i32 0 %9 = add i32 0, 0 %10 = mul i32 %9, 3 %11 = getelementptr [3 x i32], [3 x i32]* %8, i32 0, i32 0 %12 = add i32 %10, 0 %13 = getelementptr i32, i32* %11, i32 %12 %14 = load i32, i32* %13 %15 = add i32 %7, %14 %16 = getelementptr [2 x [1 x i32]], [2 x [1 x i32]]* @c, i32 0, i32 0 %17 = add i32 0, 0 %18 = mul i32 %17, 1 %19 = getelementptr [1 x i32], [1 x i32]* %16, i32 0, i32 0 %20 = add i32 %18, 0 %21 = getelementptr i32, i32* %19, i32 %20 %22 = load i32, i32* %21 %23 = add i32 %15, %22 %24 = getelementptr [3 x i32], [3 x i32]* @a, i32 0, i32 0 %25 = add i32 0, 1 %26 = getelementptr i32, i32* %24, i32 %25 %27 = load i32, i32* %26 %28 = add i32 %23, %27 %29 = getelementptr [5 x i32], [5 x i32]* @d, i32 0, i32 0 %30 = add i32 0, 4 %31 = getelementptr i32, i32* %29, i32 %30 %32 = load i32, i32* %31 %33 = add i32 %28, %32 call void @putint(i32 %33) ret i32 0 } 输出样例 2： 7 样例 3 样例程序 3： int a = 1; int b[2] = {1, a}; int main() { putint(b[1]); return 0; } 输出样例 3： 编译器直接以非 0 的返回值退出。 样例 4 样例程序 4： int arr[2][2] = {{1, 1}, {4, 5}}; int main() { arr[1] = 2; putint(arr[1][0]); return 0; } 输出样例 4： 编译器直接以非 0 的返回值退出。 "},"lab7/help.html":{"url":"lab7/help.html","title":"实验指导","keywords":"","body":"Lab 7 实验指导 理解 getElementPtr 指令 在你准备动手写这个 lab 之前，我们强烈建议你先自己写几个带有数组的程序并自己编译为 LLVM IR 看一下不同情况下 clang 是怎么做的，不然你可能会对 getElementPtr（下面简称为 GEP) 这个指令感到迷惑。如果你看完实验指导并且生成了自己的代码之后还是有疑问，可以浏览 这里。 LLVM 的指针操作 GEP 指令几乎是所有指针计算的关键。 GEP 指令的工作是“计算地址”，本身并不进行任何数据的访问和修改。GEP 指令的最基本语法为 = getelementptr , * , { }*，其中第一个 表示第一个索引所指向的类型，第二个 表示后面的指针基址 的类型， 表示一组索引的类型和值。要注意索引的类型和索引指向的基本类型是不一样的，索引的类型一般为 i32 或 i64 ，而索引指向的基本类型确定的是增加索引值时指针的偏移量。 第一个索引不会改变返回的指针的类型，也就是说 ptrval 前面的 * 对应什么类型，返回就是什么类型；第一个索引的偏移量的是由第一个索引的值和第一个 ty 指定的基本类型共同确定的。 上图中第一个索引指向的基本类型是 [6 x i8]，索引值是 1，所以 GEP 指令返回的值相对基址 @a_gv 前进了 6 个字节。由于只有一个索引，所以返回的指针也是 [6 x i8]* 类型。 而对于后面的索引，每增加一个索引，就会使得该索引使用的基本类型和返回的指针的类型去掉一层。 上图中 %elem_ptr = getelementptr [6 x i8], [6 x i8]* @a_gv, i32 0, i32 1 这一句中第一个索引值是 0，指向的类型是 [6 x i8]，因此其使返回的指针先前进 0 x 6 个字节，也就是不前进。第二个索引的值是 1，使用的基本类型就是 i8（[6 x i8] 去掉左边的 6），因此其使返回的指针前进一个字节，返回的指针类型为 i8*。 GEP 指令对于新上手的程序员来说比较难理解，所幸我们实验中涉及到指针计算的部分只有数组，而且高维数组可以用一个一维数组来模拟，比如一个 [4][5] 的二维数组，我们可以用一个 [20] 的一维数组来模拟，这就极大的减少了我们的工作量。 下面对数组 a[5][4] 中使用 GEP 指令计算 a[2][3] 的地址，给出几个使用 GEP 指令的示例： ; 1 @a = global [5 x [4 x i32]] zeroinitializer %1 = getelementptr [5 x [4 x i32]], [5 x [4 x i32]]* @a, i32 0, i32 2, i32 3 ; %1 类型为 i32* ; 2 @a = global [5 x [4 x i32]] zeroinitializer %1 = getelementptr [5 x [4 x i32]], [5 x [4 x i32]]* @a, i32 0, i32 2 ; %1 类型为 [4 x i32]*，可以理解为 C 语言中指向长度为 4 的一维数组基址的指针 %2 = getelementptr [4 x i32], [4 x i32]* %1, i32 0, i32 3 ; %2 类型为 i32* ; 3 @a = global [5 x [4 x i32]] zeroinitializer %1 = getelementptr [5 x [4 x i32]], [5 x [4 x i32]]* @a, i32 0, i32 0 ; %1 类型为 [4 x i32]* %2 = getelementptr [4 x i32], [4 x i32]* %1, i32 2, i32 3 ; %2 类型为 i32* ; 4 @a = global [20 x i32] zeroinitializer %1 = mul i32 2, 4 %2 = add i32 %1, 3 %3 = getelementptr [20 x i32], [20 x i32]* @a, i32 0, i32 %2 ; %3 类型为 i32* ; 5 @a = global [20 x i32] zeroinitializer %1 = getelementptr [20 x i32], [20 x i32]* @a, i32 0, i32 0 ; %1 类型为 i32* %2 = mul i32 2, 4 %3 = getelementptr i32, i32* %1, i32 %2 ; %3 类型为 i32* %4 = getelementptr i32, i32* %3, i32 3 ; %4 类型为 i32* "},"lab7/judge.html":{"url":"lab7/judge.html","title":"评测说明","keywords":"","body":"评测说明 本次实验的评测标识符为 lab7，即你的 judge.toml 第一行应改为 [jobs.lab7]。 你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 # 一个示例 [jobs.lab7] image = { source = \"dockerfile\", path = \".\" } run = [ \"./compiler $input $ir\", ] 如果编译过程中出现了错误（语法、语义、编译过程错误等），你的编译器应当以非 0 的返回值退出（或抛出异常）。否则如果一切正常，你的编译器应当正常退出。 "},"lab8/lab8.html":{"url":"lab8/lab8.html","title":"lab 8：函数","keywords":"","body":"Lab 8：函数 本次实验要求你的编译器在 lab 7 的基础上支持定义函数。 实验评测截止时间：2022 年 1 月 7 日 23:59 实验报告命名格式：学号_姓名_lab8.pdf 实验报告提交：北航云盘 lab8：函数/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"lab8/part13_task.html":{"url":"lab8/part13_task.html","title":"part13：函数","keywords":"","body":"Part 13 函数 在 Part 13 中，你的编译器需要支持定义函数。 如果你的 IR 指令采用数字编号，需要注意的是：函数的每个参数会分别占用一个编号。 你需要支持的语法规则如下（以 CompUnit 为开始符号）： CompUnit -> [CompUnit] (Decl | FuncDef) // [changed] Decl -> ConstDecl | VarDecl ConstDecl -> 'const' BType ConstDef { ',' ConstDef } ';' BType -> 'int' ConstDef -> Ident { '[' ConstExp ']' } '=' ConstInitVal ConstInitVal -> ConstExp | '{' [ ConstInitVal { ',' ConstInitVal } ] '}' ConstExp -> AddExp VarDecl -> BType VarDef { ',' VarDef } ';' VarDef -> Ident { '[' ConstExp ']' } | Ident { '[' ConstExp ']' } '=' InitVal InitVal -> Exp | '{' [ InitVal { ',' InitVal } ] '}' FuncDef -> FuncType Ident '(' [FuncFParams] ')' Block // [changed] FuncType -> 'void' | 'int' // [changed] FuncFParams -> FuncFParam { ',' FuncFParam } // [new] FuncFParam -> BType Ident ['[' ']' { '[' Exp ']' }] // [new] Block -> '{' { BlockItem } '}' BlockItem -> Decl | Stmt Stmt -> LVal '=' Exp ';' | Block | [Exp] ';' | 'if' '(' Cond ')' Stmt [ 'else' Stmt ] | 'while' '(' Cond ')' Stmt | 'break' ';' | 'continue' ';' | 'return' [Exp] ';' // [changed] Exp -> AddExp Cond -> LOrExp LVal -> Ident {'[' Exp ']'} PrimaryExp -> '(' Exp ')' | LVal | Number UnaryExp -> PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp UnaryOp -> '+' | '-' | '!' // 保证 '!' 只出现在 Cond 中 FuncRParams -> Exp { ',' Exp } MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp AddExp -> MulExp | AddExp ('+' | '-') MulExp RelExp -> AddExp | RelExp ('' | '=') AddExp EqExp -> RelExp | EqExp ('==' | '!=') RelExp LAndExp -> EqExp | LAndExp '&&' EqExp LOrExp -> LAndExp | LOrExp '||' LAndExp 语义约束 CompUnit 程序中必须存在且仅存在一个标识为 main、无参数、返回类型为 int 的 FuncDef，main 函数是程序的入口点。 CompUnit 的顶层变量/常量声明语句（对应 Decl）、函数定义（对应 FuncDef）都不可以重复定义同名标识符（Ident），即便标识符的类型不同也不允许。 CompUnit 的变量/常量/函数声明的作用域从该声明处开始到文件结尾。 这意味着一个函数中不能调用在它的定义之后定义的函数。 FuncFParam 与实参 FuncFParam 定义一个函数的一个形式参数。当 Ident 后面的可选部分存在时，表示该形式参数为一个数组。 当 FuncFParam 为数组定义时，其第一维的长度省去（用方括号 [] 表示），而第二维则需要用表达式指明长度，长度是编译时可求值的常量表达式。 函数实参的语法是 Exp。对于 int 类型的参数，遵循按值传递；对于数组类型的参数，则形参接收的是实参数组的地址，并通过地址间接访问实参数组中的元素。 为了简化情况，我们的测试用例中将不会出现将常量数组的地址作为实参传给函数的情况。 可以将二维数组的一部分传到形参数组中，如定义了 int a[4][3]，可以将 a[1] 作为一个包含三个元素的一维数组传递给类型为 int[] 的形参。 函数调用时，实际参数的类型和个数必须与 Ident 对应的函数定义的形参完全匹配。 FuncDef FuncDef 表示函数定义。其中的 FuncType 指明返回类型。 当返回类型为 int 时，函数内所有分支都应当含有带有 Exp 的 return 语句。不含有 return 语句的分支的返回值未定义； 当返回值类型为 void 时，函数内只能出现不带返回值的 return 语句。 运行时库的函数 你还需要支持数组相关的库函数的调用： int getarray(int []);：输入一串整数，第 1 个整数代表后续要输入的整数个数，该个数通过返回值返回；后续的整数通过传入的数组参数返回。getarray() 不会检查调用者提供的数组是否有足够的空间容纳输入的一串整数。int a[10][10]; int n; n = getarray(a[0]); void putarray(int, int[]); 第 1 个参数表示要输出的整数个数（假设为 N），后面应该跟上要输出的 N 个整数的数组。putarray() 在输出时会在整数之间安插空格。int n = 2; int a[2] = {2, 3}; putarray(n, a); 示例 样例 1 样例程序 1： int func1() { return 555; } int func2() { return 111; } int main() { int a = func1(); putint(a - func2()); return 0; } 示例 IR 1： declare void @putint(i32) define dso_local i32 @func1() { ret i32 555 } define dso_local i32 @func2() { ret i32 111 } define dso_local i32 @main() { %1 = alloca i32 %2 = call i32 @func1() store i32 %2, i32* %1 %3 = load i32, i32* %1 %4 = call i32 @func2() %5 = sub i32 %3, %4 call void @putint(i32 %5) ret i32 0 } 输出样例 1： 444 样例 2 样例程序 2： void set1(int pos, int arr[]) { arr[pos] = 1; } int main() { int a[2][5]; int n; n = getarray(a[0]); getarray(a[1]); int i = 0; while (i 示例 IR 2： declare i32 @getarray(i32*) declare void @putarray(i32, i32*) define dso_local void @set1(i32 %0, i32* %1) { %3 = alloca i32* %4 = alloca i32 store i32 %0, i32* %4 store i32* %1, i32* * %3 %5 = load i32* , i32* * %3 %6 = load i32, i32* %4 %7 = getelementptr i32, i32* %5, i32 %6 store i32 1, i32* %7 ret void } define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 %3 = alloca [2 x [5 x i32]] %4 = getelementptr [2 x [5 x i32]], [2 x [5 x i32]]* %3, i32 0, i32 0 %5 = add i32 0, 0 %6 = mul i32 %5, 5 %7 = getelementptr [5 x i32], [5 x i32]* %4, i32 0, i32 %6 %8 = call i32 @getarray(i32* %7) store i32 %8, i32* %2 %9 = getelementptr [2 x [5 x i32]], [2 x [5 x i32]]* %3, i32 0, i32 0 %10 = add i32 0, 1 %11 = mul i32 %10, 5 %12 = getelementptr [5 x i32], [5 x i32]* %9, i32 0, i32 %11 %13 = call i32 @getarray(i32* %12) store i32 0, i32* %1 br label %14 14: %15 = load i32, i32* %1 %16 = load i32, i32* %2 %17 = icmp slt i32 %15, %16 br i1 %17, label %18, label %28 18: %19 = load i32, i32* %1 %20 = getelementptr [2 x [5 x i32]], [2 x [5 x i32]]* %3, i32 0, i32 0 %21 = load i32, i32* %1 %22 = srem i32 %21, 2 %23 = add i32 0, %22 %24 = mul i32 %23, 5 %25 = getelementptr [5 x i32], [5 x i32]* %20, i32 0, i32 %24 call void @set1(i32 %19, i32* %25) %26 = load i32, i32* %1 %27 = add i32 %26, 1 store i32 %27, i32* %1 br label %14 28: %29 = load i32, i32* %2 %30 = getelementptr [2 x [5 x i32]], [2 x [5 x i32]]* %3, i32 0, i32 0 %31 = add i32 0, 0 %32 = mul i32 %31, 5 %33 = getelementptr [5 x i32], [5 x i32]* %30, i32 0, i32 %32 call void @putarray(i32 %29, i32* %33) %34 = load i32, i32* %2 %35 = getelementptr [2 x [5 x i32]], [2 x [5 x i32]]* %3, i32 0, i32 0 %36 = add i32 0, 1 %37 = mul i32 %36, 5 %38 = getelementptr [5 x i32], [5 x i32]* %35, i32 0, i32 %37 call void @putarray(i32 %34, i32* %38) ret i32 0 } 输入样例 2： 5 1 2 3 4 5 5 6 7 8 9 10 输出样例 2： 5: 1 2 1 4 1 5: 6 1 8 1 10 样例 3 样例程序 3： int gcd(int m, int n) { if (n == 0) { return m; } return gcd(n, m % n); } int main() { int a = 100, b = 48; putint(gcd(a, b)); return 0; } 示例 IR 3： declare void @putint(i32 ) define dso_local i32 @gcd(i32 %0, i32 %1) { %3 = alloca i32 %4 = alloca i32 store i32 %0, i32* %4 store i32 %1, i32* %3 %5 = load i32, i32* %3 %6 = icmp eq i32 %5, 0 br i1 %6, label %7, label %9 7: %8 = load i32, i32* %4 ret i32 %8 9: %10 = load i32, i32* %3 %11 = load i32, i32* %4 %12 = load i32, i32* %3 %13 = srem i32 %11, %12 %14 = call i32 @gcd(i32 %10, i32 %13) ret i32 %14 } define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 store i32 100, i32* %2 store i32 48, i32* %1 %3 = load i32, i32* %2 %4 = load i32, i32* %1 %5 = call i32 @gcd(i32 %3, i32 %4) call void @putint(i32 %5) ret i32 0 } 输出样例 3： 4 样例 4 样例程序 4： int sum2d(int a[][3]) { int i = 0, sum = 0; while (i 示例 IR 4： declare void @memset(i32*, i32, i32) declare void @putint(i32 ) define dso_local i32 @sum2d([3 x i32]* %0) { %2 = alloca i32 %3 = alloca i32 %4 = alloca i32 %5 = alloca [3 x i32]* store [3 x i32]* %0, [3 x i32]* * %5 store i32 0, i32* %4 store i32 0, i32* %3 br label %6 6: %7 = load i32, i32* %4 %8 = icmp slt i32 %7, 2 br i1 %8, label %12, label %10 9: store i32 0, i32* %2 br label %13 10: %11 = load i32, i32* %3 ret i32 %11 12: br label %9 13: %14 = load i32, i32* %2 %15 = icmp slt i32 %14, 3 br i1 %15, label %16, label %29 16: %17 = load i32, i32* %3 %18 = load [3 x i32]*, [3 x i32]* * %5 %19 = load i32, i32* %4 %20 = getelementptr [3 x i32], [3 x i32]* %18, i32 0 %21 = mul i32 %19, 3 %22 = load i32, i32* %2 %23 = add i32 %21, %22 %24 = getelementptr [3 x i32], [3 x i32]* %20, i32 0, i32 %23 %25 = load i32, i32* %24 %26 = add i32 %17, %25 store i32 %26, i32* %3 %27 = load i32, i32* %2 %28 = add i32 %27, 1 store i32 %28, i32* %2 br label %13 29: %30 = load i32, i32* %4 %31 = add i32 %30, 1 store i32 %31, i32* %4 br label %6 } define dso_local i32 @main() { %1 = alloca [2 x [3 x i32]] %2 = getelementptr [2 x [3 x i32]], [2 x [3 x i32]]* %1, i32 0, i32 0 %3 = getelementptr [3 x i32], [3 x i32]* %2, i32 0, i32 0 call void @memset(i32* %3, i32 0, i32 24) store i32 1, i32* %3 %4 = getelementptr i32, i32* %3, i32 1 store i32 2, i32* %4 %5 = getelementptr i32, i32* %3, i32 2 store i32 3, i32* %5 %6 = getelementptr i32, i32* %3, i32 3 store i32 4, i32* %6 %7 = getelementptr i32, i32* %3, i32 4 store i32 5, i32* %7 %8 = getelementptr [2 x [3 x i32]], [2 x [3 x i32]]* %1, i32 0, i32 0 %9 = call i32 @sum2d([3 x i32]* %8) call void @putint(i32 %9) ret i32 0 } 输出样例 4： 15 样例 5 样例程序 5： int foo(int a, int b) { int t = a + b; a = t - a; b = t - b; return a - b; } int main() { putint(foo(1, 2, 3)); return 0; } 输出样例 5： 编译器直接以非 0 的返回值退出。 "},"lab8/judge.html":{"url":"lab8/judge.html","title":"评测说明","keywords":"","body":"评测说明 本次实验的评测标识符为 lab8，即你的 judge.toml 第一行应改为 [jobs.lab8]。 你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 # 一个示例 [jobs.lab8] image = { source = \"dockerfile\", path = \".\" } run = [ \"./compiler $input $ir\", ] 如果编译过程中出现了错误（语法、语义、编译过程错误等），你的编译器应当以非 0 的返回值退出（或抛出异常）。否则如果一切正常，你的编译器应当正常退出。 "},"challenge/challenge.html":{"url":"challenge/challenge.html","title":"challenge：人类是有极限的，你不用全做","keywords":"","body":"挑战实验（人类是有极限的，所以你不用全做） 挑战实验包括以下 4 项： mem2reg（20% 分数） 多维数组（10% 分数） 函数内联（10% 分数） 短路求值（10% 分数） 挑战实验总分为 20%，你可以自由选择想做的内容，得分不会溢出，各部分会根据实验的进度放出。 完成挑战实验后，你需要在北航云盘 挑战实验/ 对应班级目录中提交你的实验报告，报告命名格式见具体实验要求。 你需要认真编写挑战实验的实验报告，详细说明你是如何完成本次挑战实验的，你对你的编译器进行了哪些改动，你参考了哪些资料，并尽可能完整地阐述你的编译器完成挑战实验任务的工作流程。如果实验报告的内容含糊不清，无法证明你独立完成本次实验，违反诚信原则，我们会酌情扣分。当然，你也需要适当地精简语言，我们对实验报告的评定点在于扣分，写出特别长的实验报告（如纯文字内容超过 7 页）并不意味着你能得到加分。 "},"challenge/mem2reg/task.html":{"url":"challenge/mem2reg/task.html","title":"任务简介","keywords":"","body":"挑战实验：mem2reg LLVM IR 借助 “memory 不是 SSA value” 的特点开了个后门。编译器前端在生成 LLVM IR 时，可以选择不生成真正的 SSA 形式，而是把局部变量生成为 alloca/load/store 形式。在本次实验中，你需要在满足前面基础实验全部要求的前提下实现 mem2reg，将局部 int 类型变量 alloca/load/store 形式的 LLVM IR 转换成真正的 SSA 形式的 LLVM IR 并输出。进行 mem2reg 后，你输出的 LLVM IR 中不能再有任何局部 int 类型变量相关的 alloca/load/store 指令，同时根据程序的语义应当会出现一些 phi 指令。 注意是局部 int 类型变量，不包括全局变量、数组等。 具体指导参考 mem2reg 实验指导。 评测 本次实验的评测标识符为 mem2reg，即你的 judge.toml 第一行应改为 [jobs.mem2reg]。 你需要从 $input 读取输入文件，将编译生成的文本格式的 LLVM IR 输出到 $ir 中，评测机会使用 lli 解释执行该文件，并评测生成的 IR 代码是否正确。请在 judge.toml 的 run 中使用 $input 代替输入文件路径，$ir 代替输出文件路径。如：./compiler $ir 或 ./compiler $input $ir 等。 # 一个示例 [jobs.mem2reg] image = { source = \"dockerfile\", path = \".\" } run = [ \"./compiler $input $ir\", ] 注意事项 你需要认真编写挑战实验的实验报告，详细说明你是如何完成本次挑战实验的，你对你的编译器进行了哪些改动，你参考了哪些资料，并尽可能完整地阐述你的编译器完成挑战实验任务的工作流程。如果实验报告的内容含糊不清，无法证明你独立完成本次实验，违反诚信原则，我们会酌情扣分。当然，你也需要适当地精简语言，我们对实验报告的评定点在于扣分，写出特别长的实验报告（如纯文字内容超过 7 页）并不意味着你能得到加分。 实验评测截止时间：2022 年 1 月 7 日 23:59 实验报告命名格式：学号_姓名_mem2reg.pdf 实验报告提交：北航云盘 挑战实验/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"challenge/mem2reg/help.html":{"url":"challenge/mem2reg/help.html","title":"实验指导","keywords":"","body":"mem2reg 实验指导 本部分的知识仅供 mem2reg 挑战实验使用，部分参考了 Static Single Assignment book 和 Engineering a Compiler。部分名词为助教自行翻译，如有困惑还请参考原书。 简介 在 LLVM 中的 SSA 中，我们简单地介绍了 SSA 的相关知识。LLVM IR 借助只要求虚拟寄存器是 SSA 形式，而内存不要求是 SSA 形式的特点开了个后门。编译器前端在生成 LLVM IR 时，可以选择不生成真正的 SSA 形式，而是把局部变量生成为 alloca/load/store 形式。 LLVM 以 pass（遍）的形式管理对 LLVM IR 的转换、分析或优化等行为，mem2reg 就是其中的一个 pass。在 mem2reg 中，LLVM 会识别出局部变量的 alloca 指令，将对应的局部变量改为虚拟寄存器中的 SSA 形式的变量，将该变量的 store/load 修改为虚拟寄存器之间的 def-use/use-def 关系，并在适当的地方加入 phi 指令和进行变量的重命名。 比如对于以下的代码： int main() { int x, cond = 1; if (cond > 0) x = 1; else x = -1; return x; } 对应的 alloca/load/store 形式的 IR 如下： define dso_local i32 @main() { %1 = alloca i32 %2 = alloca i32 store i32 1, i32* %1 %3 = load i32, i32* %1 %4 = icmp sgt i32 %3, 0 br i1 %4, label %5, label %8 5: store i32 1, i32* %2 br label %6 6: %7 = load i32, i32* %2 ret i32 %7 8: %9 = sub i32 0, 1 store i32 %9, i32* %2 br label %6 } 进行 mem2reg 后，对应的 IR 如下： define dso_local i32 @main() { %1 = icmp sgt i32 1, 0 br i1 %1, label %2, label %5 2: br label %3 3: %4 = phi i32 [ 1, %2 ], [ %6, %5 ] ret i32 %4 5: %6 = sub i32 0, 1 br label %3 } 对比发现，alloca/load/store 形式的 IR 中的 %1, %2 分别对应 x 和 cond，所有对它们的 load 指令的值（如 %3, %7）的使用被替换成了对应的 store 所写入的值。而在 mem2reg 后的 IR 的 3 基本块中，加入了一条 phi 指令，该指令根据在当前基本块执行之前执行的是哪一个基本块取不同的值。如果控制流是从 2 跳转到了 3，%4 取 1；如果控制流是从 5 跳转到了 3，%4 取 %6。需要注意一点：一个基本块中的所有 phi 指令都必须在该基本块的开头，且 phi 指令是并行取值的（当然不是机器层面的并行，只是在逻辑上要求并行），请看下面的例子： define dso_local i32 @main() { %1 = icmp slt i32 0, 5 br i1 %1, label %6, label %2 2: %3 = phi i32 [ 0, %0 ], [ %10, %6 ] %4 = phi i32 [ 0, %0 ], [ %7, %6 ] %5 = phi i32 [ 0, %0 ], [ %11, %6 ] ret i32 %5 6: %7 = phi i32 [ 0, %0 ], [ %10, %6 ] %8 = phi i32 [ 0, %0 ], [ %7, %6 ] %9 = phi i32 [ 0, %0 ], [ %11, %6 ] %10 = add i32 %7, 1 %11 = add i32 %9, 1 %12 = icmp slt i32 %7, 5 br i1 %12, label %6, label %2 } 这段 IR 解释执行后返回值为 6，而将 %10 = add i32 %7, 1 改为 %10 = add i32 %8, 1 后，返回值却变成了 10，造成这样区别的原因就在于 phi 指令的并行取值：一个基本块里的 phi 指令是同时取值的，每次从 6 跳转到 6 块时，%8 取的 %7 的值是跳转之前的 %7 的值，而非 %7 所取的 %10 的值。 前置概念 定义：对变量进行初始化、赋值等改变变量的值的行为。 使用：在语句/指令中将变量的值作为参数的行为。 控制流图（Control Flow Graph, CFG）：一个程序中所有基本块执行的可能流向图，图中的每个节点代表一个基本块，有向边代表基本块间的跳转关系. CFG 有一个入口基本块和一/多个出口基本块，分别对应程序的开始和终止. 支配（dominate）：对于 CFG 中的节点 n1n_1n1​ 和 n2n_2n2​，n1n_1n1​ 支配 n2n_2n2​ 当且仅当所有从入口节点到 n2n_2n2​ 的路径中都包含 n1n_1n1​，即 n1n_1n1​ 是从入口节点到 n2n_2n2​ 的必经节点. 每个基本块都支配自身. 严格支配（strictly dominate）：n1n_1n1​ 严格支配 n2n_2n2​ 当且仅当 n1n_1n1​ 支配 n2n_2n2​ 且 n1≠n2n_1\\neq n_2n1​​=n2​. 直接支配者（immediate dominator, idom）：节点 nnn 的直接支配者是离 nnn 最近的严格支配 nnn 的节点（标准定义是：严格支配 nnn，且不严格支配任何严格支配 nnn 的节点的节点）. 入口节点以外的节点都有直接支配者. 节点之间的直接支配关系可以形成一棵支配树（dominator tree）. 下图展示了一个 CFG 和对应的支配树： 支配边界（dominance frontier）：节点 nnn 的支配边界是 CFG 中刚好不被 nnn 支配到的节点集合. 形式化一点的定义是：节点 nnn 的支配边界 DF(n)={x∣n支配x的前驱节点，n不严格支配x}DF(n) = \\{x | n 支配 x 的前驱节点，n 不严格支配 x\\}DF(n)={x∣n支配x的前驱节点，n不严格支配x}. 在一个基本块 x 中对变量 a 进行定义，在不考虑路径中对变量进行重新定义（kill）的情况下，所有被 x 支配的基本块中，a 的值一定是 x 中所定义的值。而对于 x 的支配边界中的基本块，情况则有所不同——它们的控制流不一定来自于 x，a 的值只是有可能是 x 中所定义的值。在支配边界所支配的基本块中，当然也无法确定 a 的值，支配边界是恰好不能确定 a 是否取 x 中所定义的值的分界线。例如上面的图中，4 支配 7 的前驱节点 5，但是 4 不支配 7，4 的支配边界是 {7}，如果有个变量 a 在 2 中被声明，在 3 和 4 中分别被定义为 0 和 1，我们不能确定在程序执行到 7 时 a 的值是 0 还是 1。 计算 CFG 中每个节点的支配边界的算法如下： 为了简单起见，我们定义一个节点集的支配边界是集合中所有节点的支配边界的并集。 迭代支配边界（iterated dominance frontier）：节点集 SSS 的迭代支配边界 DF+(S)DF^{+}(S)DF+(S) 是通过迭代地计算支配边界，直到到达一个不动点得到的. 迭代方式为：DF+(S)=DFi→∞(S),  DF1(S)=DF(S),  DFi+1(S)=DF(S∪DFi(S))DF^{+} (S) = DF_{i\\to \\infty}(S),~ ~ DF_1(S)=DF(S), ~ ~ DF_{i+1}(S)=DF(S\\cup DF_i(S))DF+(S)=DFi→∞​(S),  DF1​(S)=DF(S),  DFi+1​(S)=DF(S∪DFi​(S)). SSA 构造算法 下面的 SSA 构造算法是构造 SSA 的算法的一种，是对 Static Single Assignment book Chapter 3: Standard Construction and Destruction Algorithms 中的部分内容的拙劣整合和翻译。如果你对其中的任何内容有困惑，可以直接阅读原文。 Static Single Assignment book 官方发行链接失效，原因未知。 学有余力想要了解更多 SSA 相关内容请参考 Static Single Assignment book 或其他编译优化相关书籍。 SSA 的构造分为两个阶段：插入 ϕ\\phiϕ 函数和进行变量重命名。 插入 phi 函数 如果从变量 vvv 的一个定义点 ddd 出发，存在一条路径到达程序中的另一点 ppp，并且在该路径上不存在对 vvv 的其他定义语句，那么我们称对 vvv 的定义 ddd 能够到达 ppp，说明在 ppp 处对 vvv 的取值可能是在 ddd 处定义的。如果路径上存在一个对 vvv 的其他赋值语句，即在路径上有一个定义点 d′d'd′ 也对 vvv 进行了定义，那么定义点 ddd 就被 d′d'd′ “杀死”（kill） 了。 如果一个程序中没有一个位置可以被同一个变量的两个及以上的定义到达，那么这个程序满足单一到达定义属性（single reaching-definition property）。在这样的程序中，如果 vvv 的定义 ddd 能够到达 ppp，那么在 ppp 处对 vvv 的取值一定是在 ddd 处定义的。 插入 ϕ\\phiϕ 函数的目标是生成满足单一到达定义的程序。如果我们在每个基本块的开头对基本块中的变量所使用的变量都分别设置一个 ϕ\\phiϕ 函数，在 ϕ\\phiϕ 函数处合并来自多个不同前驱基本块的对同一个变量的多个定义，显然是可以单一到达定义的要求的，但显然这样会生成大量的 ϕ\\phiϕ 函数，产生很多的冗余代码，因此我们也要尽可能地减少 ϕ\\phiϕ 函数的数量。 我们可以发现，只有在来自多个基本块的控制流汇合到一个基本块中时，才会出现同一个变量的多个不同定义，我们定义这样的有多个前驱的基本块为汇合点（join node）。对于一个基本块集合 SSS，如果一个基本块是 SSS 中的至少两个基本块的汇合点，那么这个基本块是这个集合的汇合点。基本块集合 SSS 的汇合点集记为 J(S)J(S)J(S)。 如果基本块 n1n_1n1​ 和 n2n_2n2​ 中都对 vvv 进行了定义，那么我们需要在 J(n1,n2)J({n_1,n_2})J(n1​,n2​) 中，n1, n2n_1,~n_2n1​, n2​ 的定义可以到达的所有基本块的开头对 vvv 设置一个 ϕ\\phiϕ 函数。推广一下，定义变量 vvv 的所有基本块集合为 Defs(v)\\textrm{Defs}(v)Defs(v)，我们需要在 J(Defs(v))J(\\textrm{Defs}(v))J(Defs(v)) 中的所有基本块的开头对 vvv 设置 ϕ\\phiϕ 函数，这些 ϕ\\phiϕ 函数也是对 vvv 的定义，它们对应的 ϕ\\phiϕ 函数需要在 J(Defs(v)∪J(Defs(v)))J(\\textrm{Defs}(v)\\cup J(\\textrm{Defs}(v)))J(Defs(v)∪J(Defs(v))) 中设置。不过我们可以注意到 J(S∪J(S))=J(S)J(S\\cup J(S)) = J(S)J(S∪J(S))=J(S)，因此可以得出结论为：在 J(Defs(v))J(\\textrm{Defs}(v))J(Defs(v)) 中对 vvv 设置 ϕ\\phiϕ 函数，我们就能在生成满足单一到达定义的程序的同时插入较少的 ϕ\\phiϕ 函数。 计算 J(Defs(v))J(\\textrm{Defs}(v))J(Defs(v)) 非常麻烦，不过还记得之前的迭代支配边界吗？我们有 DF+(S)=J(S∪{entry})DF^{+}(S) = J(S\\cup \\{\\textrm{entry}\\})DF+(S)=J(S∪{entry})，其中 entry\\textrm{entry}entry 为程序的入口基本块。如果变量在 entry\\textrm{entry}entry 中被定义，我们有 Defs(v)∪entry=Defs(v)\\textrm{Defs}(v)\\cup \\textrm{entry} = \\textrm{Defs}(v)Defs(v)∪entry=Defs(v)，而如果变量在 entry\\textrm{entry}entry 中没有被定义，这个 ϕ\\phiϕ 函数也可以正常构建，只不过控制流来自 entry\\textrm{entry}entry 时值为未定义，导致程序出现未定义行为。算法原作者在描述算法时默认所有的变量都在入口基本块中被定义一次，因此不会出现未定义行为。在我们的实验测试用例的中，可能会出现带有未定义值的 ϕ\\phiϕ 函数，但保证不会出现未定义行为。所以我们只需要计算出 Defs(v)\\textrm{Defs}(v)Defs(v) 的迭代支配边界，就能够知道要在哪些基本块中插入 vvv 对应的 ϕ\\phiϕ 函数。 现在，我们已经有了每个基本块的支配边界，基本块的迭代支配边界会在插入 ϕ\\phiϕ 函数的过程中迭代地计算出来。插入 ϕ\\phiϕ 函数的算法如下： 在程序中插入 ϕ\\phiϕ 函数后，程序中地每个变量依然会有多个定义，但程序中的每个定义都可以确定地到达对它的使用，在程序的任意一个位置，一定能够唯一地找到一个已定义变量的定义点，不会出现“这个变量可能在这里定义，也可能在那里定义”的情况（这种情况变成了 ϕ\\phiϕ 函数定义了该变量，kill 了原有的多个定义）。 变量重命名 为了使程序变为 SSA 形式，我们还需要对变量进行重命名。在程序中插入 ϕ\\phiϕ 函数使得每一个变量的存活区间（live-range）被切割成了几片，变量重命名要做的就是给每个单独的存活区间一个新的变量名，同时维护变量的到达定义以使程序语义和转变为 SSA 形式之前一致。在支配树上进行 DFS，DFS 的过程中，计算并更新每个变量 vvv 当前的定义 v.reachingDefv.\\textrm{reachingDef}v.reachingDef，并创建新的变量。算法如下： SSA 构造算法的应用——LLVM IR 上的 mem2reg 我们的 mem2reg 只需要对局部的 int 类型的变量进行处理。 在 mem2reg 之前，你应该已经将 miniSysY 程序编译成了 LLVM IR，并且计算出了 CFG 中的支配关系和每个基本块的支配边界。 插入 phi 指令：你需要记录下每个对局部 int 类型变量分配空间的 alloca 指令，对于每个 int 类型的变量，找到所有对应内存空间的 store 指令，这些指令对变量进行了定义。然后根据之前给出的插入 ϕ\\phiϕ 函数的算法，在基本块的开头插入空的 phi 指令，注意记录好每个 phi 指令和变量的对应关系。 变量重命名：遍历所有基本块，在每个基本块中分别遍历每条指令，遇到局部 int 类型变量对应的 alloca 指令，直接删除即可；遇到局部 int 类型变量对应的 load 指令，将所有其他指令中对该指令的使用替换为对该变量到达定义的使用，删除 load 指令；遇到局部 int 类型变量对应的 store 指令，你需要更新该变量的到达定义，删除 store 指令。遍历完成一个基本块中的所有指令后，你需要维护该基本块的所有后继基本块中的 phi 指令，将对应来自此基本块的值设为对应变量的到达定义。 变量重命名算法为了满足 SSA “每个变量都有且只有一个赋值语句” 的形式，在对变量进行定义时创建了一个新变量，通过追溯 reachingDef 链来找到原始的 reachingDef。在 LLVM IR 中，我们需要满足的性质实际上是“每个虚拟寄存器都有且只有一个赋值语句”，而我们之前生成的 LLVM IR 已经满足了这一性质，所以我们这里并没有真正地去重命名一个变量，而是维护变量的到达定义及指令对变量的使用，使程序和 mem2reg 之前的语义一致。 参考文献 如何构建 SSA 形式的 CFG_山楂片的博客 SSA - LLVM-Clang-Study-Notes 对于 LLVM 之类的编译器是如何实现在构造 SSA 形式的 IR 的时候，计算出 def-use 链？ - RednaxelaFX 的回答 - 知乎 Static Single Assignment Book: by lots of authors Engineering a Compiler: by Keith D. Cooper, Linda Torczon "},"challenge/multidimen/task.html":{"url":"challenge/multidimen/task.html","title":"任务简介","keywords":"","body":"挑战实验：多维数组 在本次挑战实验中，你的编译器需要支持理论上任意多维度的数组。 参考与帮助详见 lab7、lab8，语义约束基本保持一致 语义约束 FuncFParam 与实参 当 FuncFParam 为数组定义时，其第一维的长度省去（用方括号 [] 表示），而后面的各维则需要用表达式指明长度，长度是编译时可求值的常量表达式。 可以将多维数组的一部分传到形参数组中，如定义了 int a[2][3][4][5]，可以将 a[1][2] 作为一个第一维长度为 4，第二维长度为 5 的二维数组数组传递给类型为 int[][5] 的形参。 注意事项 本次实验的评测标识符为 mdarray，即你的 judge.toml 第一行应改为 [jobs.mdarray]。 你需要认真编写挑战实验的实验报告，详细说明你是如何完成本次挑战实验的，你对你的编译器进行了哪些改动，你参考了哪些资料，并尽可能完整地阐述你的编译器完成挑战实验任务的工作流程。如果实验报告的内容含糊不清，无法证明你独立完成本次实验，违反 诚信 原则，我们会酌情扣分。当然，你也需要适当地精简语言，我们对实验报告的评定点在于扣分，写出特别长的实验报告（如纯文字内容超过 7 页）并不意味着你能得到加分。 实验评测截止时间：2022 年 1 月 7 日 23:59 实验报告命名格式：学号_姓名_multiDimension.pdf 实验报告提交：北航云盘 挑战实验/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"challenge/functionInline/task.html":{"url":"challenge/functionInline/task.html","title":"任务简介","keywords":"","body":"挑战实验：函数内联 函数内联是一种将函数体直接展开到调用处的一种优化技术，它可以由手工指定，或者经由编译优化完成。内联是一种重要的优化技术，其好处在于消除函数的调用开销（压栈，保护/恢复），但是内联展开并不一定会导致函数性能的提升，他可能导致生成的代码的体积膨胀，并且影响指令缓存的命中率。 在本个挑战实验中，你应该对输入的源代码中的函数进行内联，策略如下： 保留 main 函数 内联所有可以内联的函数 保留无法内联的函数（递归函数） 这意味着你不用考虑内联前后的程序性能问题，只需要考虑函数是否能够被内联而不改变程序语义/造成程序错误。 一些 C 语言的例子（当然，你需要输出的是 .ll 格式的文件） 例 1 int a() { return 1; } int b() { return 2 + a(); } int c() { return 3 + b(); } int main() { return 4 + c(); } 在经过内联以后，应该变为 int main(){ return 4 + 3 + 2 + 1; } 例 2 int foo(int t) { if (t > 0) return foo(t - 1) + t; return 0; } int bar() { return foo(10) + 123; } int main() { putint(bar()); return 0; } 在经过内联以后，应该变为 int main() { putint(foo(10) + 123); return 0; } 例 3 int a = 10; void foo() { a = a + 1; } int bar(int c) { if (c == 1) return 10; else return 5; } int main(){ int b = 5; foo(); foo(); b = a + bar(2); return b; } 在经过内联以后，应该变为 int a = 10; int main() { int b = 5; a = a + 1; a = a + 1; int a_tmp_var; if (2 == 1) a_tmp_var = 10; else a_tmp_var = 5; b = a + a_tmp_var; return b; } 例 4 int foo(int t) { if (t == 1) { return 5; } else { return 10; } } int main() { return foo(1) + foo(0); } 在经过内联以后，应该变为 int main() { int tmp_val_in_llvm_ir_a; int tmp_val_in_llvm_ir_b; if (1 == 1) { tmp_val_in_llvm_ir_a = 5; } else { tmp_val_in_llvm_ir_a = 10; } if (0 == 1) { tmp_val_in_llvm_ir_b = 5; } else { tmp_val_in_llvm_ir_b = 10; } return tmp_val_in_llvm_ir_a + tmp_val_in_llvm_ir_b; } 我们会通过你输出的 .ll 格式文件中的函数的数量来检查你是否进行了内联，会通过你输出的 .ll 格式的文件经过 lli 解释执行的结果来验证你内联的正确性。 具体指导参考 函数内联实验指导。 注意事项 我们通过检测你导出的.ll格式的文件中的函数的数量以及解释执行的结果来判断你的内联是否正确。 你应该在导出的.ll格式文件中删除掉被内联以后的函数，否则将不会通过对函数数量的检测。 比如，你具有foo,main两个函数定义define @foo,define @main，在foo内联入main以后，你应该删去foo函数的原定义。 本次实验的评测标识符为 inline，即你的 judge.toml 第一行应改为 [jobs.inline]。 你需要认真编写挑战实验的实验报告，详细说明你是如何完成本次挑战实验的，你对你的编译器进行了哪些改动，你参考了哪些资料，并尽可能完整地阐述你的编译器完成挑战实验任务的工作流程。如果实验报告的内容含糊不清，无法证明你独立完成本次实验，违反 诚信 原则，我们会酌情扣分。当然，你也需要适当地精简语言，我们对实验报告的评定点在于扣分，写出特别长的实验报告（如纯文字内容超过 7 页）并不意味着你能得到加分。 实验评测截止时间：2022 年 1 月 7 日 23:59 实验报告命名格式：学号_姓名_funcInline.pdf 实验报告提交：北航云盘 挑战实验/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"challenge/functionInline/help.html":{"url":"challenge/functionInline/help.html","title":"实验指导","keywords":"","body":"函数内联实验指导 在实现函数内联时，下面是几个你可能会遇到困难的点。 如何判断一个函数能否被内联 在 miniSysY 语言中，如果一个函数不是自调用的递归函数，也不是main函数，那么它就是能够被内联的。（幸运的是，在 miniSysY 语言中没有“函数声明”这种东西，所以不会出现多个函数之间合作形成递归函数的情况） 被内联的函数原来是通过返回值来和调用它的程序互动的，内联后我怎么把两边“接上”？ 创建一个临时的匿名的变量，用于存储一个 call 指令的返回值，被内联函数的所有 return 转换为对这个临时变量的存，对内联前的 call 指令的使用转换为对这个临时的匿名变量的使用。 "},"challenge/shortcircuit/task.html":{"url":"challenge/shortcircuit/task.html","title":"任务简介","keywords":"","body":"挑战实验：短路求值 逻辑与和逻辑或操作符要求总是计算其左操作数，只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数，这被称为短路求值。 在之前的测试样例中，我们并没有针对逻辑表达式的短路求值特性进行评测，在这个实验中，你需要实现逻辑表达式的短路求值功能。 在多数情况下，逻辑表达式是否为短路求值并不会对程序的含义产生影响，但是在一些情况下不然。下面给出了一个简单的例子。 int global_variable = 0; // 全局变量 int add() { global_variable = global_variable + 1; return 1; } int main() { if (1 == 1 || 1 == add()) {} // 我们并不想 add() 函数被调用 return global_variable; } 若上述代码没有实现逻辑表达式的短路求值特性，则会先判断 1 == 1，然后判断 1 == add(), 最后将两者的结果进行或操作，这会导致函数 add() 的执行，从而导致了全局变量 global_variable 的值的改变，这是与我们的期望不符的。 一些更典型且具有实际意义的例子是（当然我们的 miniSysY 语言是没有指针的） // 一个 c 语言中的示例 void * p = NULL; int ret; /* ... */ if (p && ret = func(p) ){ } /* ... */ 这个例子展示了一种 C 语言中避免对空指针进行存取的方法。 具体指导参考 短路求值实验指导。 注意事项 本次实验的评测标识符为 short_circuit，即你的 judge.toml 第一行应改为 [jobs.short_circuit]。 我们会通过调用有副作用的函数的形式来验证你是否完成了短路求值，这意味着我们默认在进行这个实验的时候你已经完成了函数相关的 lab（也就是你的编译器已经支持了函数的定义和函数的调用）。 你需要认真编写挑战实验的实验报告，详细说明你是如何完成本次挑战实验的，你对你的编译器进行了哪些改动，你参考了哪些资料，并尽可能完整地阐述你的编译器完成挑战实验任务的工作流程。如果实验报告的内容含糊不清，无法证明你独立完成本次实验，违反 诚信 原则，我们会酌情扣分。当然，你也需要适当地精简语言，我们对实验报告的评定点在于扣分，写出特别长的实验报告（如纯文字内容超过 7 页）并不意味着你能得到加分。 实验评测截止时间：2022 年 1 月 7 日 23:59 实验报告命名格式：学号_姓名_shortCircuit.pdf 实验报告提交：北航云盘 挑战实验/ 对应班级目录中 实验报告提交截止时间：2022 年 1 月 9 日 23:59 "},"challenge/shortcircuit/help.html":{"url":"challenge/shortcircuit/help.html","title":"实验指导","keywords":"","body":"短路求值实验指导 短路求值（Short-circuit evaluation，又称最小化求值），是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。例如，当 AND 的第一个运算数的值为 false 时，其结果必定为 false；当 OR 的第一个运算数为 true 时，最后结果必定为 true，在这种情况下，就不需要知道第二个运算数的具体值。 现代的编译器在处理具有短路求值的条件表达式时，一般是通过控制流来实现短路求值的。 控制流法 也被称做“跳转法”，顾名思义，就是通过条件跳转来实现短路求值的语义。 比如说，下面这个例子 if (a && b && c) { do_something(); } do_others(); 每一个方框都代表着一个基本块，true 和 false 由 br 指令体现： 比如 if(a && b && c) 的代码，交给编译器，它生成的代码的逻辑实际上是类似这样的： ; ; 其他代码，%a, %b, %c 在此被定义 ; block_entry: br label %block_a block_a: %res_a = icmp ne i32 %a, 0 br i1 %res_a label block_b, label %block_out block_b: %res_b = icmp ne i32 %b, 0 br i1 %res_b label block_c, label %block_out block_c: %res_c = icmp ne i32 %c, 0 br i1 %res_a label block_exec, label %block_out block_exec: do_sth() ; a, b, c 都为真，执行语句内内容 block_out: ; a, b, c 不都为真，跳到这个块 do_others() 从上面可以看到，我们通过多个基本块和跳转指令实现了短路求值。这体现在，如果 a, b, c 中任何一个非真，都会直接跳到 block_out，而如果 a / b 为真，则会跳转到 block_b/c 中判断 b/c, 而在最后的 block_c 中，如果 c 也为真，则程序会跳转到 block_exec 中执行对应语句。 参考文献 本节参考了 R 大的知乎回答 维基百科 "},"ref.html":{"url":"ref.html","title":"参考文献","keywords":"","body":"参考文献 灵感来源 https://decaf-lang.github.io/minidecaf-tutorial/ SYSY 语言原始定义 https://gitlab.eduxiji.net/nscscc/compiler2021/-/blob/master/SysY%E8%AF%AD%E8%A8%80%E5%AE%9A%E4%B9%89.pdf LLVM IR lang ref https://llvm.org/docs/LangRef.html LLVM Programmer Manual https://llvm.org/docs/ProgrammersManual.html#the-core-llvm-class-hierarchy-reference Often misunderstood GEP Instruction https://llvm.org/docs/GetElementPtr.html Mem2reg 算法以及其他 https://llvm-clang-study-notes.readthedocs.io/en/latest/ssa/Mem2Reg.html LLVM IR 介绍 https://www.cnblogs.com/Five100Miles/category/1438128.html LLVM 中文网 https://llvm.liuxfe.com/docs/man/lli LLVM IR 入门指南 https://github.com/Evian-Zhang/llvm-ir-tutoria 知乎专栏：A Tour to LLVM IR上 https://zhuanlan.zhihu.com/p/66793637下 https://zhuanlan.zhihu.com/p/66909226 LLVM SSA 介绍 https://blog.csdn.net/qq_29674357/article/details/78731713 自己动手写编译器 https://pandolia.net/tinyc/ Implementing a JIT Compiled Language with Haskell and LLVM https://www.bookstack.cn/read/stephendiehl-llvm/spilt.1.llvm.md "},"others.html":{"url":"others.html","title":"其他","keywords":"","body":""},"thanks.html":{"url":"thanks.html","title":"致谢","keywords":"","body":"致谢 感谢下列朋友们的帮助，没有他们的帮助，这个实验不可能顺利地进行。 （顺序随机打乱） rynco 提供评测机，配置评测机环境，答疑 holmium 编写示例编译器，答疑 roife 编写示例编译器，答疑，文档重审 dglr 编写示例编译器 "},"example.html":{"url":"example.html","title":"示例编译器","keywords":"","body":"示例编译器 rust + 手动递归下降解析 实现https://github.com/roife/racoon JAVA + ANTLR 实现https://github.com/BUAA-SE-Compiling/miniSysY_example_compiler "}}